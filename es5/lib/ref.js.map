{"version":3,"names":[],"mappings":"","sources":["lib/ref.js"],"sourcesContent":["\nvar assert = require('assert')\nvar debug = require('debug')('ref')\n\nexports = module.exports = require('bindings')('ref')\n\n/**\n * A `Buffer` that references the C NULL pointer. That is, its memory address\n * points to 0. Its `length` is 0 because accessing any data from this buffer\n * would cause a _segmentation fault_.\n *\n * ```\n * console.log(ref.NULL);\n * <SlowBuffer@0x0 >\n * ```\n *\n * @name NULL\n * @type Buffer\n */\n\n/**\n * A string that represents the native endianness of the machine's processor.\n * The possible values are either `\"LE\"` or `\"BE\"`.\n *\n * ```\n * console.log(ref.endianness);\n * 'LE'\n * ```\n *\n * @name endianness\n * @type String\n */\n\n/**\n * Accepts a `Buffer` instance and returns the memory address of the buffer\n * instance.\n *\n * ```\n * console.log(ref.address(new Buffer(1)));\n * 4320233616\n *\n * console.log(ref.address(ref.NULL)));\n * 0\n * ```\n *\n * @param {Buffer} buffer The buffer to get the memory address of.\n * @return {Number} The memory address the buffer instance.\n * @name address\n * @type method\n */\n\n/**\n * Accepts a `Buffer` instance and returns _true_ if the buffer represents the\n * NULL pointer, _false_ otherwise.\n *\n * ```\n * console.log(ref.isNull(new Buffer(1)));\n * false\n *\n * console.log(ref.isNull(ref.NULL));\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to check for NULL.\n * @return {Boolean} true or false.\n * @name isNull\n * @type method\n */\n\n/**\n * Reads a JavaScript Object that has previously been written to the given\n * _buffer_ at the given _offset_.\n *\n * ```\n * var obj = { foo: 'bar' };\n * var buf = ref.alloc('Object', obj);\n *\n * var obj2 = ref.readObject(buf, 0);\n * console.log(obj === obj2);\n * true\n * ```\n *\n * @param {Buffer} buffer The buffer to read an Object from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Object} The Object that was read from _buffer_.\n * @name readObject\n * @type method\n */\n\n/**\n * Reads a Buffer instance from the given _buffer_ at the given _offset_.\n * The _size_ parameter specifies the `length` of the returned Buffer instance,\n * which defaults to __0__.\n *\n * ```\n * var buf = new Buffer('hello world');\n * var pointer = ref.alloc('pointer');\n *\n * var buf2 = ref.readPointer(pointer, 0, buf.length);\n * console.log(buf.toString());\n * 'hello world'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.\n * @return {Buffer} The Buffer instance that was read from _buffer_.\n * @name readPointer\n * @type method\n */\n\n/**\n * Returns a JavaScript String read from _buffer_ at the given _offset_. The\n * C String is read until the first NULL byte, which indicates the end of the\n * String.\n *\n * This function can read beyond the `length` of a Buffer.\n *\n * ```\n * var buf = new Buffer('hello\\0world\\0');\n *\n * var str = ref.readCString(buf, 0);\n * console.log(str);\n * 'hello'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {String} The String that was read from _buffer_.\n * @name readCString\n * @type method\n */\n\n/**\n * Returns a big-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64BE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian signed 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n *\n * var val = ref.readInt64LE(buf, 0)\n * console.log(val)\n * '9223372036854775807'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readInt64LE\n * @type method\n */\n\n/**\n * Returns a big-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64BE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64BE\n * @type method\n */\n\n/**\n * Returns a little-endian unsigned 64-bit int read from _buffer_ at the given\n * _offset_.\n *\n * If the returned value will fit inside a JavaScript Number without losing\n * precision, then a Number is returned, otherwise a String is returned.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n *\n * var val = ref.readUInt64LE(buf, 0)\n * console.log(val)\n * '18446744073709551615'\n * ```\n *\n * @param {Buffer} buffer The buffer to read a Buffer from.\n * @param {Number} offset The offset to begin reading from.\n * @return {Number|String} The Number or String that was read from _buffer_.\n * @name readUInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian signed 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('int64');\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeInt64LE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a big-endian unsigned 64-bit int into\n * _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64BE\n * @type method\n */\n\n/**\n * Writes the _input_ Number or String as a little-endian unsigned 64-bit int\n * into _buffer_ at the given _offset_.\n *\n * ```\n * var buf = ref.alloc('uint64');\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\n * ```\n *\n * @param {Buffer} buffer The buffer to write to.\n * @param {Number} offset The offset to begin writing from.\n * @param {Number|String} input This String or Number which gets written.\n * @name writeUInt64LE\n * @type method\n */\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level incremented by **1**.\n *\n * Say you wanted to create a type representing a `void *`:\n *\n * ```\n * var voidPtrType = ref.refType(ref.types.void);\n * ```\n *\n * @param {Object|String} type The \"type\" object to create a reference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` incremented by 1.\n */\n\nexports.refType = function refType (type) {\n  var _type = exports.coerceType(type)\n  var rtn = Object.create(_type)\n  rtn.indirection++\n  if (_type.name) {\n    rtn.name = _type.name + '*'\n  }\n  return rtn\n}\n\n/**\n * Returns a new clone of the given \"type\" object, with its\n * `indirection` level decremented by 1.\n *\n * @param {Object|String} type The \"type\" object to create a dereference type from. Strings get coerced first.\n * @return {Object} The new \"type\" object with its `indirection` decremented by 1.\n */\n\nexports.derefType = function derefType (type) {\n  var _type = exports.coerceType(type)\n  if (_type.indirection === 1) {\n    throw new Error('Cannot create deref\\'d type for type with indirection 1')\n  }\n  var rtn = Object.getPrototypeOf(_type)\n  if (rtn.indirection !== _type.indirection - 1) {\n    // slow case\n    rtn = Object.create(_type)\n    rtn.indirection--\n  }\n  return rtn\n}\n\n/**\n * Coerces a \"type\" object from a String or an actual \"type\" object. String values\n * are looked up from the `ref.types` Object. So:\n *\n *   * `\"int\"` gets coerced into `ref.types.int`.\n *   * `\"int *\"` gets translated into `ref.refType(ref.types.int)`\n *   * `ref.types.int` gets translated into `ref.types.int` (returns itself)\n *\n * Throws an Error if no valid \"type\" object could be determined. Most `ref`\n * functions use this function under the hood, so anywhere a \"type\" object is\n * expected, a String may be passed as well, including simply setting the\n * `buffer.type` property.\n *\n * ```\n * var type = ref.coerceType('int **');\n *\n * console.log(type.indirection);\n * 3\n * ```\n *\n * @param {Object|String} type The \"type\" Object or String to coerce.\n * @return {Object} A \"type\" object\n */\n\nexports.coerceType = function coerceType (type) {\n  var rtn = type\n  if (typeof rtn === 'string') {\n    rtn = exports.types[type]\n    if (rtn) return rtn\n\n    // strip whitespace\n    rtn = type.replace(/\\s+/g, '').toLowerCase()\n    if (rtn === 'pointer') {\n      // legacy \"pointer\" being used :(\n      rtn = exports.refType(exports.types.void) // void *\n    } else if (rtn === 'string') {\n      rtn = exports.types.CString // special char * type\n    } else {\n      var refCount = 0\n      rtn = rtn.replace(/\\*/g, function () {\n        refCount++\n        return ''\n      })\n      // allow string names to be passed in\n      rtn = exports.types[rtn]\n      if (refCount > 0) {\n        if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n          throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n        }\n        for (var i = 0; i < refCount; i++) {\n          rtn = exports.refType(rtn)\n        }\n      }\n    }\n  }\n  if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\n    throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\n  }\n  return rtn\n}\n\n/**\n * Returns the \"type\" property of the given Buffer.\n * Creates a default type for the buffer when none exists.\n *\n * @param {Buffer} buffer The Buffer instance to get the \"type\" object from.\n * @return {Object} The \"type\" object from the given Buffer.\n */\n\nexports.getType = function getType (buffer) {\n  if (!buffer.type) {\n    debug('WARN: no \"type\" found on buffer, setting default \"type\"', buffer)\n    buffer.type = {}\n    buffer.type.size = buffer.length\n    buffer.type.indirection = 1\n    buffer.type.get = function get () {\n      throw new Error('unknown \"type\"; cannot get()')\n    }\n    buffer.type.set = function set () {\n      throw new Error('unknown \"type\"; cannot set()')\n    }\n  }\n  return exports.coerceType(buffer.type)\n}\n\n/**\n * Calls the `get()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level and returning a\n * proper \"dereferenced\" Bufffer instance when necessary.\n *\n * @param {Buffer} buffer The Buffer instance to read from.\n * @param {Number} offset (optional) The offset on the Buffer to start reading from. Defaults to 0.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n * @return {?} Whatever value the \"type\" used when reading returns.\n */\n\nexports.get = function get (buffer, offset, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('get(): (offset: %d)', offset, buffer)\n  assert(type.indirection > 0, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    // need to check \"type\"\n    return type.get(buffer, offset)\n  } else {\n    // need to create a deref'd Buffer\n    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer\n    var reference = exports.readPointer(buffer, offset, size)\n    reference.type = exports.derefType(type)\n    return reference\n  }\n}\n\n/**\n * Calls the `set()` function of the Buffer's current \"type\" (or the\n * passed in _type_ if present) at the given _offset_.\n *\n * This function handles checking the \"indirection\" level writing a pointer rather\n * than calling the `set()` function if the indirection is greater than 1.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset on the Buffer to start writing to.\n * @param {?} value The value to write to the Buffer instance.\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\n */\n\nexports.set = function set (buffer, offset, value, type) {\n  if (!offset) {\n    offset = 0\n  }\n  if (type) {\n    type = exports.coerceType(type)\n  } else {\n    type = exports.getType(buffer)\n  }\n  debug('set(): (offset: %d)', offset, buffer, value)\n  assert(type.indirection >= 1, '\"indirection\" level must be at least 1')\n  if (type.indirection === 1) {\n    type.set(buffer, offset, value)\n  } else {\n    exports.writePointer(buffer, offset, value)\n  }\n}\n\n\n/**\n * Returns a new Buffer instance big enough to hold `type`,\n * with the given `value` written to it.\n *\n * ``` js\n * var intBuf = ref.alloc(ref.types.int)\n * var int_with_4 = ref.alloc(ref.types.int, 4)\n * ```\n *\n * @param {Object|String} type The \"type\" object to allocate. Strings get coerced first.\n * @param {?} value (optional) The initial value set on the returned Buffer, using _type_'s `set()` function.\n * @return {Buffer} A new Buffer instance with it's `type` set to \"type\", and (optionally) \"value\" written to it.\n */\n\nexports.alloc = function alloc (_type, value) {\n  var type = exports.coerceType(_type)\n  debug('allocating Buffer for type with \"size\"', type.size)\n  var size\n  if (type.indirection === 1) {\n    size = type.size\n  } else {\n    size = exports.sizeof.pointer\n  }\n  var buffer = new Buffer(size)\n  buffer.type = type\n  if (arguments.length >= 2) {\n    debug('setting value on allocated buffer', value)\n    exports.set(buffer, 0, value, type)\n  }\n  return buffer\n}\n\n/**\n * Returns a new `Buffer` instance with the given String written to it with the\n * given encoding (defaults to __'utf8'__). The buffer is 1 byte longer than the\n * string itself, and is NUL terminated.\n *\n * ```\n * var buf = ref.allocCString('hello world');\n *\n * console.log(buf.toString());\n * 'hello world\\u0000'\n * ```\n *\n * @param {String} string The JavaScript string to be converted to a C string.\n * @param {String} encoding (optional) The encoding to use for the C string. Defaults to __'utf8'__.\n * @return {Buffer} The new `Buffer` instance with the specified String wrtten to it, and a trailing NUL byte.\n */\n\nexports.allocCString = function allocCString (string, encoding) {\n  if (null == string || (Buffer.isBuffer(string) && exports.isNull(string))) {\n    return exports.NULL\n  }\n  var size = Buffer.byteLength(string, encoding) + 1\n  var buffer = new Buffer(size)\n  exports.writeCString(buffer, 0, string, encoding)\n  buffer.type = charPtrType\n  return buffer\n}\n\n/**\n * Writes the given string as a C String (NULL terminated) to the given buffer\n * at the given offset. \"encoding\" is optional and defaults to __'utf8'__.\n *\n * Unlike `readCString()`, this function requires the buffer to actually have the\n * proper length.\n *\n * @param {Buffer} buffer The Buffer instance to write to.\n * @param {Number} offset The offset of the buffer to begin writing at.\n * @param {String} string The JavaScript String to write that will be written to the buffer.\n * @param {String} encoding (optional) The encoding to read the C string as. Defaults to __'utf8'__.\n */\n\nexports.writeCString = function writeCString (buffer, offset, string, encoding) {\n  assert(Buffer.isBuffer(buffer), 'expected a Buffer as the first argument')\n  assert.equal('string', typeof string, 'expected a \"string\" as the third argument')\n  if (!offset) {\n    offset = 0\n  }\n  if (!encoding) {\n    encoding = 'utf8'\n  }\n  var size = buffer.length - offset\n  var len = buffer.write(string, offset, size, encoding)\n  buffer.writeUInt8(0, offset + len)  // NUL terminate\n}\n\nexports['readInt64' + exports.endianness] = exports.readInt64\nexports['readUInt64' + exports.endianness] = exports.readUInt64\nexports['writeInt64' + exports.endianness] = exports.writeInt64\nexports['writeUInt64' + exports.endianness] = exports.writeUInt64\n\nvar opposite = exports.endianness == 'LE' ? 'BE' : 'LE'\nvar int64temp = new Buffer(exports.sizeof.int64)\nvar uint64temp = new Buffer(exports.sizeof.uint64)\n\nexports['readInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]\n  }\n  return exports.readInt64(int64temp, 0)\n}\nexports['readUInt64' + opposite] = function (buffer, offset) {\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]\n  }\n  return exports.readUInt64(uint64temp, 0)\n}\nexports['writeInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeInt64(int64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.int64; i++) {\n    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]\n  }\n}\nexports['writeUInt64' + opposite] = function (buffer, offset, value) {\n  exports.writeUInt64(uint64temp, 0, value)\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\n    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]\n  }\n}\n\n/**\n * `ref()` accepts a Buffer instance and returns a new Buffer\n * instance that is \"pointer\" sized and has its data pointing to the given\n * Buffer instance. Essentially the created Buffer is a \"reference\" to the\n * original pointer, equivalent to the following C code:\n *\n * ``` c\n * char *buf = buffer;\n * char **ref = &buf;\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to create a reference to.\n * @return {Buffer} A new Buffer instance pointing to _buffer_.\n */\n\nexports.ref = function ref (buffer) {\n  debug('creating a reference to buffer', buffer)\n  var type = exports.refType(exports.getType(buffer))\n  return exports.alloc(type, buffer)\n}\n\n/**\n * Accepts a Buffer instance and attempts to \"dereference\" it.\n * That is, first it checks the `indirection` count of _buffer_'s \"type\", and if\n * it's greater than __1__ then it merely returns another Buffer, but with one\n * level less `indirection`.\n *\n * When _buffer_'s indirection is at __1__, then it checks for `buffer.type`\n * which should be an Object with its own `get()` function.\n *\n * ```\n * var buf = ref.alloc('int', 6);\n *\n * var val = ref.deref(buf);\n * console.log(val);\n * 6\n * ```\n *\n *\n * @param {Buffer} buffer A Buffer instance to dereference.\n * @return {?} The returned value after dereferencing _buffer_.\n */\n\nexports.deref = function deref (buffer) {\n  debug('dereferencing buffer', buffer)\n  return exports.get(buffer)\n}\n\n/**\n * Attaches _object_ to _buffer_ such that it prevents _object_ from being garbage\n * collected until _buffer_ does.\n *\n * @param {Buffer} buffer A Buffer instance to attach _object_ to.\n * @param {Object|Buffer} object An Object or Buffer to prevent from being garbage collected until _buffer_ does.\n * @api private\n */\n\nexports._attach = function _attach (buf, obj) {\n  if (!buf._refs) {\n    buf._refs = []\n  }\n  buf._refs.push(obj)\n}\n\n/**\n * Same as `ref.writeObject()`, except that this version does not _attach_ the\n * Object to the Buffer, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n * @api private\n */\n\nexports._writeObject = exports.writeObject\n\n/**\n * Writes a pointer to _object_ into _buffer_ at the specified _offset.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var buf = ref.alloc('Object');\n * ref.writeObject(buf, 0, { foo: 'bar' });\n *\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Object} object The Object to be written into _buffer_.\n */\n\nexports.writeObject = function writeObject (buf, offset, obj, persistent) {\n  debug('writing Object to buffer', buf, offset, obj, persistent)\n  exports._writeObject(buf, offset, obj, persistent)\n  exports._attach(buf, obj)\n}\n\n/**\n * Same as `ref.writePointer()`, except that this version does not attach\n * _pointer_ to _buffer_, which is potentially unsafe if the garbage collector\n * runs.\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n * @api private\n */\n\nexports._writePointer = exports.writePointer\n\n/**\n * Writes the memory address of _pointer_ to _buffer_ at the specified _offset_.\n *\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\n * collected.\n *\n * ```\n * var someBuffer = new Buffer('whatever');\n * var buf = ref.alloc('pointer');\n * ref.writePointer(buf, 0, someBuffer);\n * ```\n *\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\n * @param {Number} offset The offset on the Buffer to start writing at.\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\n */\n\nexports.writePointer = function writePointer (buf, offset, ptr) {\n  debug('writing pointer to buffer', buf, offset, ptr)\n  exports._writePointer(buf, offset, ptr)\n  exports._attach(buf, ptr)\n}\n\n/**\n * Same as `ref.reinterpret()`, except that this version does not attach\n * _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n * @api private\n */\n\nexports._reinterpret = exports.reinterpret\n\n/**\n * Returns a new Buffer instance with the specified _size_, with the same memory\n * address as _buffer_.\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The `length` property of the returned Buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\n */\n\nexports.reinterpret = function reinterpret (buffer, size, offset) {\n  debug('reinterpreting buffer to \"%d\" bytes', size)\n  var rtn = exports._reinterpret(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n/**\n * Same as `ref.reinterpretUntilZeros()`, except that this version does not\n * attach _buffer_ to the returned Buffer, which is potentially unsafe if the\n * garbage collector runs.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n * @api private\n */\n\nexports._reinterpretUntilZeros = exports.reinterpretUntilZeros\n\n/**\n * Accepts a `Buffer` instance and a number of `NULL` bytes to read from the\n * pointer. This function will scan past the boundary of the Buffer's `length`\n * until it finds `size` number of aligned `NULL` bytes.\n *\n * This is useful for finding the end of NUL-termintated array or C string. For\n * example, the `readCString()` function _could_ be implemented like:\n *\n * ```\n * function readCString (buf) {\n *   return ref.reinterpretUntilZeros(buf, 1).toString('utf8')\n * }\n * ```\n *\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\n * being garbage collected.\n *\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\n * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.\n * @param {Number} offset The offset of the Buffer to begin from.\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\n */\n\nexports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {\n  debug('reinterpreting buffer to until \"%d\" NULL (0) bytes are found', size)\n  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)\n  exports._attach(rtn, buffer)\n  return rtn\n}\n\n\n// the built-in \"types\"\nvar types = exports.types = {}\n\n/**\n * The `void` type.\n *\n * @section types\n */\n\ntypes.void = {\n    size: 0\n  , indirection: 1\n  , get: function get (buf, offset) {\n      debug('getting `void` type (returns `null`)')\n      return null\n    }\n  , set: function set (buf, offset, val) {\n      debug('setting `void` type (no-op)')\n    }\n}\n\n/**\n * The `int8` type.\n */\n\ntypes.int8 = {\n    size: exports.sizeof.int8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `uint8` type.\n */\n\ntypes.uint8 = {\n    size: exports.sizeof.uint8\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readUInt8(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      if (typeof val === 'string') {\n        val = val.charCodeAt(0)\n      }\n      return buf.writeUInt8(val, offset || 0)\n    }\n}\n\n/**\n * The `int16` type.\n */\n\ntypes.int16 = {\n    size: exports.sizeof.int16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint16` type.\n */\n\ntypes.uint16 = {\n    size: exports.sizeof.uint16\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt16' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt16' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int32` type.\n */\n\ntypes.int32 = {\n    size: exports.sizeof.int32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint32` type.\n */\n\ntypes.uint32 = {\n    size: exports.sizeof.uint32\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt32' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt32' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `int64` type.\n */\n\ntypes.int64 = {\n    size: exports.sizeof.int64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `uint64` type.\n */\n\ntypes.uint64 = {\n    size: exports.sizeof.uint64\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readUInt64' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeUInt64' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `float` type.\n */\n\ntypes.float = {\n    size: exports.sizeof.float\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readFloat' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeFloat' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `double` type.\n */\n\ntypes.double = {\n    size: exports.sizeof.double\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf['readDouble' + exports.endianness](offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf['writeDouble' + exports.endianness](val, offset || 0)\n    }\n}\n\n/**\n * The `Object` type. This can be used to read/write regular JS Objects\n * into raw memory.\n */\n\ntypes.Object = {\n    size: exports.sizeof.Object\n  , indirection: 1\n  , get: function get (buf, offset) {\n      return buf.readObject(offset || 0)\n    }\n  , set: function set (buf, offset, val) {\n      return buf.writeObject(val, offset || 0)\n    }\n}\n\n/**\n * The `CString` (a.k.a `\"string\"`) type.\n *\n * CStrings are a kind of weird thing. We say it's `sizeof(char *)`, and\n * `indirection` level of 1, which means that we have to return a Buffer that\n * is pointer sized, and points to a some utf8 string data, so we have to create\n * a 2nd \"in-between\" buffer.\n */\n\ntypes.CString = {\n    size: exports.sizeof.pointer\n  , alignment: exports.alignof.pointer\n  , indirection: 1\n  , get: function get (buf, offset) {\n      var _buf = exports.readPointer(buf, offset)\n      if (exports.isNull(_buf)) {\n        return null\n      }\n      return exports.readCString(_buf, 0)\n    }\n  , set: function set (buf, offset, val) {\n      var _buf\n      if (Buffer.isBuffer(val)) {\n        _buf = val\n      } else {\n        // assume string\n        _buf = exports.allocCString(val)\n      }\n      return exports.writePointer(buf, offset, _buf)\n    }\n}\n\n// alias Utf8String\nvar utfstringwarned = false\nObject.defineProperty(types, 'Utf8String', {\n    enumerable: false\n  , configurable: true\n  , get: function () {\n      if (!utfstringwarned) {\n        utfstringwarned = true\n        console.error('\"Utf8String\" type is deprecated, use \"CString\" instead')\n      }\n      return types.CString\n    }\n})\n\n/**\n * The `bool` type.\n *\n * Wrapper type around `types.uint8` that accepts/returns `true` or\n * `false` Boolean JavaScript values.\n *\n * @name bool\n *\n */\n\n/**\n * The `byte` type.\n *\n * @name byte\n */\n\n/**\n * The `char` type.\n *\n * @name char\n */\n\n/**\n * The `uchar` type.\n *\n * @name uchar\n */\n\n/**\n * The `short` type.\n *\n * @name short\n */\n\n/**\n * The `ushort` type.\n *\n * @name ushort\n */\n\n/**\n * The `int` type.\n *\n * @name int\n */\n\n/**\n * The `uint` type.\n *\n * @name uint\n */\n\n/**\n * The `long` type.\n *\n * @name long\n */\n\n/**\n * The `ulong` type.\n *\n * @name ulong\n */\n\n/**\n * The `longlong` type.\n *\n * @name longlong\n */\n\n/**\n * The `ulonglong` type.\n *\n * @name ulonglong\n */\n\n/**\n * The `size_t` type.\n *\n * @name size_t\n */\n\n// \"typedef\"s for the variable-sized types\n;[ 'bool', 'byte', 'char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long'\n, 'ulong', 'longlong', 'ulonglong', 'size_t' ].forEach(function (name) {\n  var unsigned = name === 'bool'\n              || name === 'byte'\n              || name === 'size_t'\n              || name[0] === 'u'\n  var size = exports.sizeof[name]\n  assert(size >= 1 && size <= 8)\n  var typeName = 'int' + (size * 8)\n  if (unsigned) {\n    typeName = 'u' + typeName\n  }\n  var type = exports.types[typeName]\n  assert(type)\n  exports.types[name] = Object.create(type)\n})\n\n// set the \"alignment\" property on the built-in types\nObject.keys(exports.alignof).forEach(function (name) {\n  if (name === 'pointer') return\n  exports.types[name].alignment = exports.alignof[name]\n  assert(exports.types[name].alignment > 0)\n})\n\n// make the `bool` type work with JS true/false values\nexports.types.bool.get = (function (_get) {\n  return function get (buf, offset) {\n    return _get(buf, offset) ? true : false\n  }\n})(exports.types.bool.get)\nexports.types.bool.set = (function (_set) {\n  return function set (buf, offset, val) {\n    if (typeof val !== 'number') {\n      val = val ? 1 : 0\n    }\n    return _set(buf, offset, val)\n  }\n})(exports.types.bool.set)\n\n/*!\n * Set the `name` property of the types. Used for debugging...\n */\n\nObject.keys(exports.types).forEach(function (name) {\n  exports.types[name].name = name\n})\n\n/*!\n * This `char *` type is used by \"allocCString()\" above.\n */\n\nvar charPtrType = exports.refType(exports.types.char)\n\n/*!\n * Set the `type` property of the `NULL` pointer Buffer object.\n */\n\nexports.NULL.type = exports.types.void\n\n/**\n * `NULL_POINTER` is a pointer-sized `Buffer` instance pointing to `NULL`.\n * Conceptually, it's equivalent to the following C code:\n *\n * ``` c\n * char *null_pointer;\n * null_pointer = NULL;\n * ```\n *\n * @type Buffer\n */\n\nexports.NULL_POINTER = exports.ref(exports.NULL)\n\n/**\n * All these '...' comment blocks below are for the documentation generator.\n *\n * @section buffer\n */\n\nBuffer.prototype.address = function address () {\n  return exports.address(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.hexAddress = function hexAddress () {\n  return exports.hexAddress(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.isNull = function isNull () {\n  return exports.isNull(this, 0)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.ref = function ref () {\n  return exports.ref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.deref = function deref () {\n  return exports.deref(this)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readObject = function readObject (offset) {\n  return exports.readObject(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeObject = function writeObject (obj, offset) {\n  return exports.writeObject(this, offset, obj)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readPointer = function readPointer (offset, size) {\n  return exports.readPointer(this, offset, size)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writePointer = function writePointer (ptr, offset) {\n  return exports.writePointer(this, offset, ptr)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readCString = function readCString (offset) {\n  return exports.readCString(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeCString = function writeCString (string, offset, encoding) {\n  return exports.writeCString(this, offset, string, encoding)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64BE = function readInt64BE (offset) {\n  return exports.readInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64BE = function writeInt64BE (val, offset) {\n  return exports.writeInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64BE = function readUInt64BE (offset) {\n  return exports.readUInt64BE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64BE = function writeUInt64BE (val, offset) {\n  return exports.writeUInt64BE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readInt64LE = function readInt64LE (offset) {\n  return exports.readInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeInt64LE = function writeInt64LE (val, offset) {\n  return exports.writeInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.readUInt64LE = function readUInt64LE (offset) {\n  return exports.readUInt64LE(this, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.writeUInt64LE = function writeUInt64LE (val, offset) {\n  return exports.writeUInt64LE(this, offset, val)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpret = function reinterpret (size, offset) {\n  return exports.reinterpret(this, size, offset)\n}\n\n/**\n * ...\n */\n\nBuffer.prototype.reinterpretUntilZeros = function reinterpretUntilZeros (size, offset) {\n  return exports.reinterpretUntilZeros(this, size, offset)\n}\n\n/**\n * `ref` overwrites the default `Buffer#inspect()` function to include the\n * hex-encoded memory address of the Buffer instance when invoked.\n *\n * This is simply a nice-to-have.\n *\n * **Before**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer 72 65 66>\n * ```\n *\n * **After**:\n *\n * ``` js\n * console.log(new Buffer('ref'));\n * <Buffer@0x103015490 72 65 66>\n * ```\n */\n\nBuffer.prototype.inspect = overwriteInspect(Buffer.prototype.inspect)\n\n// does SlowBuffer inherit from Buffer? (node >= v0.7.9)\nif (!(exports.NULL instanceof Buffer)) {\n  debug('extending SlowBuffer\\'s prototype since it doesn\\'t inherit from Buffer.prototype')\n\n  /*!\n   * SlowBuffer convenience methods.\n   */\n\n  var SlowBuffer = require('buffer').SlowBuffer\n\n  SlowBuffer.prototype.address = Buffer.prototype.address\n  SlowBuffer.prototype.hexAddress = Buffer.prototype.hexAddress\n  SlowBuffer.prototype.isNull = Buffer.prototype.isNull\n  SlowBuffer.prototype.ref = Buffer.prototype.ref\n  SlowBuffer.prototype.deref = Buffer.prototype.deref\n  SlowBuffer.prototype.readObject = Buffer.prototype.readObject\n  SlowBuffer.prototype.writeObject = Buffer.prototype.writeObject\n  SlowBuffer.prototype.readPointer = Buffer.prototype.readPointer\n  SlowBuffer.prototype.writePointer = Buffer.prototype.writePointer\n  SlowBuffer.prototype.readCString = Buffer.prototype.readCString\n  SlowBuffer.prototype.writeCString = Buffer.prototype.writeCString\n  SlowBuffer.prototype.reinterpret = Buffer.prototype.reinterpret\n  SlowBuffer.prototype.reinterpretUntilZeros = Buffer.prototype.reinterpretUntilZeros\n  SlowBuffer.prototype.readInt64BE = Buffer.prototype.readInt64BE\n  SlowBuffer.prototype.writeInt64BE = Buffer.prototype.writeInt64BE\n  SlowBuffer.prototype.readUInt64BE = Buffer.prototype.readUInt64BE\n  SlowBuffer.prototype.writeUInt64BE = Buffer.prototype.writeUInt64BE\n  SlowBuffer.prototype.readInt64LE = Buffer.prototype.readInt64LE\n  SlowBuffer.prototype.writeInt64LE = Buffer.prototype.writeInt64LE\n  SlowBuffer.prototype.readUInt64LE = Buffer.prototype.readUInt64LE\n  SlowBuffer.prototype.writeUInt64LE = Buffer.prototype.writeUInt64LE\n  SlowBuffer.prototype.inspect = overwriteInspect(SlowBuffer.prototype.inspect)\n}\n\nfunction overwriteInspect (inspect) {\n  if (inspect.name === 'refinspect') {\n    return inspect\n  } else {\n    return function refinspect () {\n      var v = inspect.apply(this, arguments)\n      return v.replace('Buffer', 'Buffer@0x' + this.hexAddress())\n    }\n  }\n}\n"],"file":"ref.js"}