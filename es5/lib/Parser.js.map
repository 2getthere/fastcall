{"version":3,"sources":["../../lib/Parser.js"],"names":["_","require","assert","verify","a","ert","ref","util","rex","typeCode","FunctionParser","RefTypeParser","MultilineParser","refHelpers","Parser","library","functionParser","refTypeParser","multilineParser","def","parse","typeHint","str","callMode","args","title","trim","pos","lastIndexOf","length","part1","substr","part2","defaultName","name","type","_makeRef","isInterface","value","isInteface","undefined","isString","callback","callbacks","code","match","matchType","structs","unions","arrays","_makeTypeWithLength","starCount","countStars","stars","i","refType","indirection","isArrayType","getForType","propertyName","coerceType","_ensureRegistered","count","ch","rootType","derefType","regBy","isStructType","isUnionType","makeName","defObj","isObject","result","each","key","_resolveStringType","findRefDeclaration","module","exports"],"mappings":"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","file":"Parser.js","sourcesContent":["/*\r\nCopyright 2016 Gábor Mező (gabor.mezo@outlook.com)\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\n'use strict';\r\nconst _ = require('lodash');\r\nconst assert = require('assert');\r\nconst verify = require('./verify');\r\nconst a = verify.a;\r\nconst ert = verify.ert;\r\nconst ref = require('./ref-libs/ref');\r\nconst util = require('util');\r\nconst rex = require('./rex');\r\nconst typeCode = require('./typeCode');\r\nconst FunctionParser = require('./FunctionParser');\r\nconst RefTypeParser = require('./RefTypeParser');\r\nconst MultilineParser = require('./MultilineParser');\r\nconst refHelpers = require('./refHelpers');\r\n\r\nclass Parser {\r\n    constructor(library) {\r\n        a&&ert(library);\r\n\r\n        this.library = library;\r\n        this.functionParser = new FunctionParser(this);\r\n        this.refTypeParser = new RefTypeParser(this);\r\n        this.multilineParser = new MultilineParser(this);\r\n    }\r\n\r\n    parseFunction(def) {\r\n        return this.functionParser.parse(def);\r\n    }\r\n\r\n    parseRefType(def, typeHint) {\r\n        return this.refTypeParser.parse(def, typeHint);\r\n    }\r\n\r\n    parseMultiline(str, callMode) {\r\n        return this.multilineParser.parse(str, callMode);\r\n    }\r\n\r\n    _parseDeclaration(args) {\r\n        let def = args.def;\r\n        const title = args.title;\r\n        def = def.trim();\r\n        assert(def, `Invalid ${ title }: ${ def }`);\r\n        let pos = _.lastIndexOf(def, ' ');\r\n        if (pos === -1) {\r\n            pos = _.lastIndexOf(def, '*');\r\n        }\r\n        if (pos === -1) {\r\n            pos = def.length - 1;\r\n        }\r\n        let part1 = def.substr(0, pos + 1).trim();\r\n        let part2 = def.substr(pos + 1).trim();\r\n        if (!part1 && part2) {\r\n            part1 = part2;\r\n            part2 = null;\r\n        }\r\n        assert(part1, `Invalid ${ title }: ${ def }`);\r\n        if (!part2 && !args.defaultName) {\r\n            assert(false, `${ title } declaration's name expected.`);\r\n        }\r\n        return {\r\n            name: part2 || args.defaultName,\r\n            type: this._makeRef(part1, args.isInterface)\r\n        };\r\n    }\r\n\r\n    _makeRef(value, isInteface) {\r\n        if (isInteface === undefined) {\r\n            isInteface = true;\r\n        }\r\n        if (_.isString(value)) {\r\n            const callback = this.library.callbacks[value];\r\n            if (callback) {\r\n                a&&ert(callback.type.code);\r\n                a&&ert(callback.type.callback === callback);\r\n                return callback.type;\r\n            }\r\n            const match = rex.matchType(value);\r\n            if (match) {\r\n                const name = match.name;\r\n                const def = this.library.structs[name] || \r\n                    this.library.unions[name] ||\r\n                    this.library.arrays[name];\r\n                if (def) {\r\n                    let type = def.type;\r\n                    if (match.length) {\r\n                        type = def._makeTypeWithLength(match.length);\r\n                    }\r\n                    const starCount = countStars(match.stars);\r\n                    for (let i = 0; i < starCount; i++) {\r\n                        type = ref.refType(type);\r\n                    }\r\n                    if (isInteface) {\r\n                        assert(\r\n                            type.indirection > 1 || refHelpers.isArrayType(type), \r\n                            'Using struct or unions by value on function interfaces is not supported.');\r\n                    }\r\n                    if (starCount) {\r\n                        if (type.code === undefined) {\r\n                            type.code = typeCode.getForType(type);\r\n                        }\r\n                        if (type[def.propertyName] === undefined) {\r\n                            type[def.propertyName] = def;\r\n                        }\r\n                    }\r\n                    return type;\r\n                }\r\n            }\r\n        }\r\n        const type = ref.coerceType(value);\r\n        if (type.code === undefined) {\r\n            type.code = typeCode.getForType(type);\r\n        }\r\n        this._ensureRegistered(type);\r\n        return type;\r\n\r\n        function countStars(def) {\r\n            let count = 0;\r\n            for (let ch of def) {\r\n                if (ch === '*') {\r\n                    ++count;\r\n                }\r\n            }\r\n            return count;\r\n        }\r\n    }\r\n\r\n    _ensureRegistered(type) {\r\n        let rootType = type;\r\n        while (rootType.indirection > 1 || refHelpers.isArrayType(rootType)) {\r\n            if (rootType.indirection > 1) {\r\n                rootType = ref.derefType(rootType);\r\n            }\r\n            else {\r\n                rootType = rootType.type;\r\n            }\r\n        }\r\n        let regBy = null;\r\n        if (refHelpers.isStructType(rootType)) {\r\n            regBy = 'struct';\r\n        }\r\n        else if (refHelpers.isUnionType(rootType)) {\r\n            regBy = 'union';\r\n        }\r\n        else if (refHelpers.isArrayType(rootType)) {\r\n            regBy = 'array';\r\n        }\r\n\r\n        if (!regBy) {\r\n            return;\r\n        }\r\n\r\n        this.library[regBy]({ [this.library.makeName(rootType.name)]: rootType });\r\n    }\r\n\r\n    _resolveStringTypes(defObj) {\r\n        a&&ert(_.isObject(defObj));\r\n\r\n        const result = {};\r\n        _.each(defObj, (value, key) => {\r\n            let type = defObj[key];\r\n            if (_.isString(type)) {\r\n                type = this._resolveStringType(type);\r\n            }\r\n            result[key] = type;\r\n        });\r\n        return result;\r\n    }\r\n\r\n    _resolveStringType(type) {\r\n        a&&ert(_.isString(type));\r\n\r\n        let match = rex.matchType(type);\r\n        if (match) {\r\n            type = match.name;\r\n            let def = this.library.findRefDeclaration(type);\r\n            if (def) {\r\n                type = def.type;\r\n                if (match.length) {\r\n                    type = def._makeTypeWithLength(match.length);\r\n                }\r\n            }\r\n        }\r\n        return type;\r\n    }\r\n}\r\n\r\nmodule.exports = Parser;"]}