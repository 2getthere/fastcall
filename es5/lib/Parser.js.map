{"version":3,"sources":["../../lib/Parser.js"],"names":["_","require","assert","verify","ref","util","IS_X64","process","arch","Parser","library","def","isPlainObject","keys","length","name","arr","isArray","resultType","_makeRef","args","i","push","type","isString","parts","exec","trim","split","map","_parseDeclaration","arg","defaultName","isInterface","keyword","rex","RegExp","match","content","defBody","part","fieldDecl","decl","pos","lastIndexOf","part1","substr","part2","value","isInteface","undefined","callback","callbacks","code","nameMatch","structs","unions","arrays","_makeTypeWithLength","starCount","_countStars","refType","getTypeCode","propertyName","coerceType","_ensureRegistered","rootType","indirection","derefType","regTo","regBy","typeStr","String","makeName","iStr","isObject","getTypeode","count","ch","module","exports"],"mappings":"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","file":"Parser.js","sourcesContent":["'use strict';\nconst _ = require('lodash');\nconst assert = require('assert');\nconst verify = require('./verify');\nconst ref = require('./ref-libs/ref');\nconst util = require('util');\n\nconst IS_X64 = process.arch === 'x64';\n\nclass Parser {\n    constructor(library) {\n        verify(library);\n\n        this.library = library;\n    }\n\n    parseFunctionObject(def) {\n        verify(_.isPlainObject(def));\n\n        // node-ffi format\n        const keys = _.keys(def);\n        assert(keys.length === 1, 'Object has invalid number of keys.');\n        const name = keys[0];\n        const arr = def[name];\n        assert(_.isArray(arr), 'Function definition array expected.');\n        assert(arr.length > 1, 'Function definition array is empty.');\n        const resultType = this._makeRef(arr[0]);\n        const args = [];\n        if (_.isArray(arr[1])) {\n            for (let i = 0; i < arr[1].length; i++) {\n                args.push({\n                    name: 'arg' + i,\n                    type: this._makeRef(arr[1][i])\n                });\n            }\n        }\n        return { resultType, name, args };\n    }\n\n    parseFunctionString(def) {\n        verify(_.isString(def));\n\n        let parts = /^\\s*([\\w_][\\w\\d_]*\\s*\\**)\\s*([\\w_][\\w\\d_]*)\\s*\\((.*)\\)\\s*$/.exec(def);\n        assert(parts && parts.length === 4, 'Invalid function definition format.');\n        const resultType = this._makeRef(parts[1]);\n        const name = parts[2].trim();\n        let args = parts[3].trim();\n        args = args ? args.split(',') : [];\n        let i = 0;\n        args = args.map(arg => this._parseDeclaration({\n            def: arg,\n            name: 'argument',\n            defaultName: 'arg' + i++,\n            isInterface: true\n        }));\n        return { resultType, name, args };\n    }\n\n    parseFields(def, keyword) {\n        verify(_.isString(def));\n\n        const rex = new RegExp(keyword + '\\\\s*(\\\\w+)\\\\s*{(.*)}');\n        const match = rex.exec(def);\n        assert(match && match.length === 3, `Invalid ${ keyword } definition format.`);\n        const name = match[1];\n        const content = match[2];\n        const parts = content.split(';');\n        const defBody = {};\n        for (const part of parts) {\n            const fieldDecl = part.trim();\n            if (fieldDecl) {\n                const decl = this._parseDeclaration({\n                    def: part,\n                    name: 'declaration',\n                    isInterface: false\n                });\n                defBody[decl.name] = decl.type;\n            }\n        }\n\n        return { name, defBody };\n    }\n\n    parseArray(def) {\n        verify(_.isString(def));\n\n        const match = /(\\w+)\\s*\\[\\s*\\]\\s*(\\w+)/.exec(def);\n        assert(match && match.length === 3, `Invalid array definition format.`);\n\n        return { name: match[2], defBody: match[1] };\n    }\n\n    _parseDeclaration(args) {\n        let def = args.def;\n        const name = args.name;\n        def = def.trim();\n        assert(def, `Invalid ${ name }: ${ def }`);\n        let pos = _.lastIndexOf(def, ' ');\n        if (pos === -1) {\n            pos = _.lastIndexOf(def, '*');\n        }\n        if (pos === -1) {\n            pos = def.length - 1;\n        }\n        let part1 = def.substr(0, pos + 1).trim();\n        let part2 = def.substr(pos + 1).trim();\n        if (!part1 && part2) {\n            part1 = part2;\n            part2 = null;\n        }\n        assert(part1, `Invalid ${ name }: ${ def }`);\n        if (!part2 && !args.defaultName) {\n            assert(false, `${ name } declaration's name expected.`);\n        }\n        return {\n            name: part2 || args.defaultName,\n            type: this._makeRef(part1, args.isInterface)\n        };\n    }\n\n    _makeRef(value, isInteface) {\n        if (isInteface === undefined) {\n            isInteface = true;\n        }\n        if (_.isString(value)) {\n            const callback = this.library.callbacks[value];\n            if (callback) {\n                verify(callback.type.code);\n                verify(callback.type.callback === callback);\n                return callback.type;\n            }\n            const nameMatch = /((\\w+)\\s*(?:\\[\\s*(\\d+)\\s*\\])?)([\\s\\*]*)/.exec(value);\n            if (nameMatch && nameMatch.length === 5) {\n                const name = nameMatch[2];\n                const def = this.library.structs[name] || \n                    this.library.unions[name] ||\n                    this.library.arrays[name];\n                if (def) {\n                    let type = def.type;\n                    if (nameMatch[3]) {\n                        type = def._makeTypeWithLength(nameMatch[3]);\n                    }\n                    const starCount = Parser._countStars(nameMatch[4]);\n                    if (isInteface) {\n                        assert(starCount, 'Using struct or unions by value on function interfaces is not supported.');\n                    }\n                    for (let i = 0; i < starCount; i++) {\n                        type = ref.refType(type);\n                    }\n                    if (starCount) {\n                        type.code = Parser.getTypeCode(type);\n                    }\n                    type[def.propertyName] = def;\n                    return type;\n                }\n            }\n        }\n        const type = ref.coerceType(value);\n        type.code = Parser.getTypeCode(type);\n        this._ensureRegistered(type);\n        return type;\n    }\n\n    _ensureRegistered(type) {\n        let rootType = type;\n        while (rootType.indirection > 1) {\n            rootType = ref.derefType(rootType);\n        }\n        let regTo = null;\n        let regBy = null;\n        const typeStr = String(rootType);\n        if (typeStr === '[StructType]') {\n            regTo = this.library.structs;\n            regBy = 'struct';\n        }\n        else if (typeStr === '[UnionType]') {\n            regTo = this.library.unions;\n            regBy = 'union';\n        }\n        else if (typeStr === '[ArrayType]') {\n            regTo = this.library.arrays;\n            regBy = 'array';\n        }\n\n        if (!regTo) {\n            return;\n        }\n\n        let i = 0;\n        let name = makeName(i);\n        while (regTo[name]) {\n            name = makeName(++i);\n        }\n\n        this.library[regBy]({ [name]: rootType });\n\n        function makeName(i) {\n            let iStr = String(i);\n            if (iStr.length === 0) {\n                iStr = '0' + iStr;\n            }\n            return rootType.name + iStr;\n        }\n    }\n\n    static getTypeCode(type) {\n        const indirection = _.isObject(type) ? type.indirection : 0;\n        const name = _.isString(type) ? type : type.name;\n\n        if (indirection > 1) {\n            return 'p';\n        }\n        switch (name) {\n            case 'bool':\n                return 'B';\n            case 'char':\n                return 'c';\n            case 'uchar':\n                return 'C';\n            case 'short':\n                return 's';\n            case 'ushort':\n                return 'S';\n            case 'int':\n                return 'i';\n            case 'uint':\n                return 'I';\n            case 'long':\n                return 'j';\n            case 'ulong':\n                return 'J';\n            case 'longlong':\n                return 'l';\n            case 'ulonglong':\n                return 'L';\n            case 'float':\n                return 'f';\n            case 'double':\n                return 'd';\n            case 'int8':\n                return Parser.getTypeCode('char');\n            case 'uint8':\n                return Parser.getTypeCode('uchar');\n            case 'int16':\n                return Parser.getTypeCode('short');\n            case 'uint16':\n                return Parser.getTypeCode('ushort');\n            case 'int32':\n                return Parser.getTypeode('int');\n            case 'uint32':\n                return Parser.getTypeode('uint');\n            case 'int64':\n                return Parser.getTypeCode('longlong');\n            case 'uint64':\n                return Parser.getTypeCode('ulonglong');\n            case 'size_t':\n                return Parser.getTypeCode('ulong');\n            case 'byte':\n                return Parser.getTypeCode('uint8');\n            case 'void':\n                return 'v';\n            default:\n                assert(false, 'Unknonwn type: ' + type.name);\n        }\n    }\n\n    static _countStars(def) {\n        let count = 0;\n        for (let ch of def) {\n            if (ch === '*') {\n                ++count;\n            }\n        }\n        return count;\n    }\n}\n\nmodule.exports = Parser;"]}