{"version":3,"sources":["../../lib/RefTypeDefinition.js"],"names":["_","require","assert","verify","ref","Parser","RefTypeDefinition","args","isObject","library","isString","propertyName","_FactoryType","FactoryType","def","parsed","_parse","name","_defBody","defBody","_type","_typeFactory","keys","isFunction","factory","makePtr","value","type","propName","Buffer","isPlainObject","isArray","buffer","TypeError","str","parser","parseFields","_resolveStringTypes","_resolveStringType","defObj","result","each","key","match","exec","findRefDeclaration","_makeTypeWithLength","len","Number","parseInt","itemType","module","exports"],"mappings":"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","file":"RefTypeDefinition.js","sourcesContent":["'use strict';\nconst _ = require('lodash');\nconst assert = require('assert');\nconst verify = require('./verify');\nconst ref = require('./ref-libs/ref');\nconst Parser = require('./Parser');\n\nclass RefTypeDefinition {\n    constructor(args) {\n        verify(args);\n\n        assert(_.isObject(args.library), '\"library\" is not an object.');\n        verify(_.isString(args.propertyName), '\"args.propertyName\" is not a string.');\n        this.library = args.library;\n        this.propertyName = args.propertyName;\n        this._FactoryType = args.FactoryType;\n\n        if (_.isString(args.def)) {\n            const parsed = this._parse(args.def);\n            this.name = parsed.name;\n            this._defBody = parsed.defBody;\n            this._type = this._typeFactory();\n        }\n        else {\n            this.name = _.keys(args.def)[0];\n            assert(_.isString(this.name), '\"def\" is invalid.');\n            this._defBody = args.def[this.name];\n\n            if (_.isFunction(this._defBody)) {\n                this._type = this._defBody;\n            }\n            else if (_.isObject(this._defBody) || _.isString(this._defBody)) {\n                this._type = this._typeFactory();\n            }\n            else {\n                assert(false, '\"def\" is invalid.');\n            }\n        }\n        this._type[this.propertyName] = this;\n    }\n\n    get type() {\n        return this._type;\n    }\n\n    getFactory() {\n        const factory = value => this.makePtr(value);\n        factory[this.propertyName] = this;\n        factory.type = this.type;\n        return factory;\n    }\n\n    makePtr(value) {\n        const propName = this.propertyName;\n        if (value) {\n            if (value instanceof Buffer) {\n                return value;\n            }\n\n            if (_.isPlainObject(value) || _.isArray(value) || _.isString(value)) {\n                value = new this.type(value);\n            }\n\n            if (value.buffer instanceof Buffer) {\n                value = value.buffer;\n            }\n            else if (_.isFunction(value.ref)) {\n                value = value.ref();\n            }\n\n            if (!value.type) {\n                value.type = this.type;\n            }\n            \n            if (!value[propName]) {\n                value[propName] = this;\n            }\n\n            return value;\n        }\n        else if (value === null) {\n            return null;\n        }\n        throw new TypeError(`Cannot make ${ propName } from: ` + value);\n    }\n\n    _parse(str) {\n        const parser = new Parser(this.library);\n        return parser.parseFields(str, this.propertyName);\n    }\n\n    _typeFactory() {\n        verify(_.isFunction(this._FactoryType), '\"args.FactoryType\" is not a function.');\n        verify(this._defBody);\n        if (_.isPlainObject(this._defBody)) {\n            this._defBody = this._resolveStringTypes(this._defBody);\n        }\n        if (_.isString(this._defBody)) {\n            this._defBody = this._resolveStringType(this._defBody);\n        }\n        return new this._FactoryType(this._defBody);\n    }\n\n    _resolveStringTypes(defObj) {\n        const result = {};\n        _.each(defObj, (value, key) => {\n            let type = defObj[key];\n            if (_.isString(type)) {\n                type = this._resolveStringType(type);\n            }\n            result[key] = type;\n        });\n        return result;\n    }\n\n    _resolveStringType(type) {\n        let match = /(\\w+)\\s*(?:\\[\\s*(\\d+)\\s*\\])?/.exec(type);\n        if (match) {\n            type = match[1];\n            let def = this.library.findRefDeclaration(type);\n            if (def) {\n                type = def.type;\n                if (match[2]) {\n                    type = def._makeTypeWithLength(match[2]);\n                }\n            }\n        }\n        return type;\n    }\n\n    _makeTypeWithLength(len) {\n        len = _.isString(len) ? Number.parseInt(len) : len;\n        let itemType = this._defBody;\n        let FactoryType = this._FactoryType;\n        assert(len > 0 && itemType && _.isFunction(FactoryType), 'Invalid array type definition.');\n        return new FactoryType(itemType, len);\n    }\n}\n\nmodule.exports = RefTypeDefinition;"]}