{"version":3,"sources":["../../../lib/ref-libs/union.js"],"names":["ref","require","assert","debug","module","exports","Union","UnionType","arg","data","store","Buffer","isBuffer","length","size","type","key","_instanceCreated","prototype","Object","create","proto","constructor","value","enumerable","writable","configurable","defineProperty","toString","fields","alignment","indirection","get","set","arguments","keys","forEach","name","buffer","offset","slice","union","isUnion","coerceType","equal","test","desc","field","cacheName","recalc","got","fieldNames","sizeof","pointer","alignof","Math","max","left","NULL"],"mappings":"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","file":"union.js","sourcesContent":["\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar ref = require('./ref')\r\nvar assert = require('assert')\r\nvar debug = require('debug')('ref-union')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = Union\r\n\r\n/**\r\n * The \"Union\" type constructor.\r\n */\r\n\r\nfunction Union () {\r\n  debug('defining new union \"type\"')\r\n\r\n  function UnionType (arg, data) {\r\n    if (!(this instanceof UnionType)) {\r\n      return new UnionType(arg, data)\r\n    }\r\n    debug('creating new union instance')\r\n    var store\r\n    if (Buffer.isBuffer(arg)) {\r\n      debug('using passed-in Buffer instance to back the union', arg)\r\n      assert(arg.length >= UnionType.size, 'Buffer instance must be at least '\r\n          + UnionType.size + ' bytes to back this untion type')\r\n      store = arg\r\n      arg = data\r\n    } else {\r\n      debug('creating new Buffer instance to back the union (size: %d)', UnionType.size)\r\n      store = new Buffer(UnionType.size)\r\n    }\r\n\r\n    // set the backing Buffer store\r\n    store.type = UnionType\r\n    this['ref.buffer'] = store\r\n\r\n    // initialise the union with values supplied\r\n    if (arg) {\r\n      //TODO: Sanity check - e.g. (Object.keys(arg).length == 1)\r\n      for (var key in arg) {\r\n        // hopefully hit the union setters\r\n        this[key] = arg[key]\r\n      }\r\n    }\r\n    UnionType._instanceCreated = true\r\n  }\r\n\r\n  // make instances inherit from `proto`\r\n  UnionType.prototype = Object.create(proto, {\r\n    constructor: {\r\n        value: UnionType\r\n      , enumerable: false\r\n      , writable: true\r\n      , configurable: true\r\n    }\r\n  })\r\n\r\n  UnionType.defineProperty = defineProperty\r\n  UnionType.toString = toString\r\n  UnionType.fields = {}\r\n\r\n  // comply with ref's \"type\" interface\r\n  UnionType.size = 0\r\n  UnionType.alignment = 0\r\n  UnionType.indirection = 1\r\n  UnionType.get = get\r\n  UnionType.set = set\r\n\r\n  // Read the fields list\r\n  var arg = arguments[0]\r\n  if (typeof arg === 'object') {\r\n    Object.keys(arg).forEach(function (name) {\r\n      var type = arg[name];\r\n      UnionType.defineProperty(name, type);\r\n    })\r\n  }\r\n\r\n  return UnionType\r\n}\r\n\r\nfunction get (buffer, offset) {\r\n  debug('Union \"type\" getter for buffer at offset', buffer, offset)\r\n  if (offset > 0) {\r\n    buffer = buffer.slice(offset)\r\n  }\r\n  return new this(buffer)\r\n}\r\n\r\nfunction set (buffer, offset, value) {\r\n  debug('Union \"type\" setter for buffer at offset', buffer, offset, value)\r\n  if (offset > 0) {\r\n    buffer = buffer.slice(offset)\r\n  }\r\n  var union = new this(buffer)\r\n  var isUnion = value instanceof this\r\n  if (isUnion) {\r\n    // TODO: optimize - use Buffer#copy()\r\n    Object.keys(this.fields).forEach(function (name) {\r\n      // hopefully hit the setters\r\n      union[name] = value[name]\r\n    })\r\n  } else {\r\n    for (var name in value) {\r\n      // hopefully hit the setters\r\n      union[name] = value[name]\r\n    }\r\n  }\r\n}\r\n\r\nfunction toString () {\r\n  return '[UnionType]'\r\n}\r\n\r\n/**\r\n * Adds a new field to the union instance with the given name and type.\r\n * Note that this function will throw an Error if any instances of the union\r\n * type have already been created, therefore this function must be called at the\r\n * beginning, before any instances are created.\r\n */\r\n\r\nfunction defineProperty (name, type) {\r\n  debug('defining new union type field', name)\r\n\r\n  // allow string types for convenience\r\n  type = ref.coerceType(type)\r\n\r\n  assert(!this._instanceCreated, 'an instance of this Union type has already '\r\n      + 'been created, cannot add new data members anymore')\r\n  assert.equal('string', typeof name, 'expected a \"string\" field name')\r\n  assert(type && /object|function/i.test(typeof type) && 'size' in type &&\r\n      'indirection' in type\r\n      , 'expected a \"type\" object describing the field type: \"' + type + '\"')\r\n  assert(!(name in this.prototype), 'the field \"' + name\r\n      + '\" already exists in this Union type')\r\n\r\n  // define the getter/setter property\r\n  var desc = {\r\n      enumerable: true\r\n    , configurable: true\r\n    , get: get\r\n    , set: set\r\n  };\r\n  Object.defineProperty(this.prototype, name, desc);\r\n\r\n  var field = {\r\n    type: type\r\n  }\r\n  this.fields[name] = field\r\n  var cacheName = '_cache' + name\r\n\r\n  // calculate the new size and alignment\r\n  recalc(this);\r\n\r\n  function get () {\r\n    if (this[cacheName]) {\r\n      return this[cacheName]\r\n    }\r\n    debug('getting \"%s\" union field (length: %d)', name, type.size)\r\n    var got = ref.get(this['ref.buffer'], 0, type)\r\n    if (typeof got === 'object') {\r\n      this[cacheName] = got;\r\n    }\r\n    return got;\r\n  }\r\n\r\n  function set (value) {\r\n    this[cacheName] = null\r\n    debug('setting \"%s\" union field (length: %d)', name, type.size, value)\r\n    return ref.set(this['ref.buffer'], 0, value, type)\r\n  }\r\n}\r\n\r\nfunction recalc (union) {\r\n  // reset size and alignment\r\n  union.size = 0\r\n  union.alignment = 0\r\n\r\n  var fieldNames = Object.keys(union.fields)\r\n\r\n  // loop through to set the size of the union of the largest member field\r\n  // and the alignment to the requirements of the largest member\r\n  fieldNames.forEach(function (name) {\r\n    var field = union.fields[name]\r\n    var type = field.type\r\n\r\n    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer\r\n    var alignment = type.alignment || ref.alignof.pointer\r\n    if (type.indirection > 1) {\r\n      alignment = ref.alignof.pointer\r\n    }\r\n    union.alignment = Math.max(union.alignment, alignment)\r\n    union.size = Math.max(union.size, size)\r\n  })\r\n\r\n  // any padding\r\n  var left = union.size % union.alignment\r\n  if (left > 0) {\r\n    debug('additional padding to the end of union:', union.alignment - left)\r\n    union.size += union.alignment - left\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * the base prototype that union type instances will inherit from.\r\n */\r\n\r\nvar proto = {}\r\n\r\nproto['ref.buffer'] = ref.NULL\r\n\r\n/**\r\n * returns a Buffer pointing to this union data structure.\r\n */\r\n\r\nproto.ref = function ref () {\r\n  return this['ref.buffer']\r\n}\r\n"]}