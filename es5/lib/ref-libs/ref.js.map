{"version":3,"sources":["../../../lib/ref-libs/ref.js"],"names":["assert","require","debug","exports","module","refType","type","_type","coerceType","rtn","Object","create","indirection","name","derefType","Error","getPrototypeOf","types","replace","toLowerCase","void","CString","refCount","TypeError","JSON","stringify","i","getType","buffer","size","length","get","set","offset","sizeof","pointer","reference","readPointer","value","writePointer","alloc","Buffer","arguments","allocCString","string","encoding","isBuffer","isNull","NULL","byteLength","writeCString","charPtrType","equal","len","write","writeUInt8","endianness","readInt64","readUInt64","writeInt64","writeUInt64","opposite","int64temp","int64","uint64temp","uint64","ref","deref","_attach","buf","obj","_refs","push","_writeObject","writeObject","persistent","_writePointer","ptr","_reinterpret","reinterpret","_reinterpretUntilZeros","reinterpretUntilZeros","val","int8","readInt8","charCodeAt","writeInt8","uint8","readUInt8","int16","uint16","int32","uint32","float","double","readObject","alignment","alignof","_buf","readCString","utfstringwarned","defineProperty","enumerable","configurable","console","error","forEach","unsigned","typeName","keys","bool","_get","_set","char","NULL_POINTER","prototype","address","hexAddress","readInt64BE","writeInt64BE","readUInt64BE","writeUInt64BE","readInt64LE","writeInt64LE","readUInt64LE","writeUInt64LE","inspect","overwriteInspect","SlowBuffer","refinspect","v","apply"],"mappings":"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","file":"ref.js","sourcesContent":["\r\nvar assert = require('assert')\r\nvar debug = require('debug')('ref')\r\n\r\nexports = module.exports = require('bindings')('ref')\r\n\r\n/**\r\n * A `Buffer` that references the C NULL pointer. That is, its memory address\r\n * points to 0. Its `length` is 0 because accessing any data from this buffer\r\n * would cause a _segmentation fault_.\r\n *\r\n * ```\r\n * console.log(ref.NULL);\r\n * <SlowBuffer@0x0 >\r\n * ```\r\n *\r\n * @name NULL\r\n * @type Buffer\r\n */\r\n\r\n/**\r\n * A string that represents the native endianness of the machine's processor.\r\n * The possible values are either `\"LE\"` or `\"BE\"`.\r\n *\r\n * ```\r\n * console.log(ref.endianness);\r\n * 'LE'\r\n * ```\r\n *\r\n * @name endianness\r\n * @type String\r\n */\r\n\r\n/**\r\n * Accepts a `Buffer` instance and returns the memory address of the buffer\r\n * instance.\r\n *\r\n * ```\r\n * console.log(ref.address(new Buffer(1)));\r\n * 4320233616\r\n *\r\n * console.log(ref.address(ref.NULL)));\r\n * 0\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to get the memory address of.\r\n * @return {Number} The memory address the buffer instance.\r\n * @name address\r\n * @type method\r\n */\r\n\r\n/**\r\n * Accepts a `Buffer` instance and returns _true_ if the buffer represents the\r\n * NULL pointer, _false_ otherwise.\r\n *\r\n * ```\r\n * console.log(ref.isNull(new Buffer(1)));\r\n * false\r\n *\r\n * console.log(ref.isNull(ref.NULL));\r\n * true\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to check for NULL.\r\n * @return {Boolean} true or false.\r\n * @name isNull\r\n * @type method\r\n */\r\n\r\n/**\r\n * Reads a JavaScript Object that has previously been written to the given\r\n * _buffer_ at the given _offset_.\r\n *\r\n * ```\r\n * var obj = { foo: 'bar' };\r\n * var buf = ref.alloc('Object', obj);\r\n *\r\n * var obj2 = ref.readObject(buf, 0);\r\n * console.log(obj === obj2);\r\n * true\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read an Object from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {Object} The Object that was read from _buffer_.\r\n * @name readObject\r\n * @type method\r\n */\r\n\r\n/**\r\n * Reads a Buffer instance from the given _buffer_ at the given _offset_.\r\n * The _size_ parameter specifies the `length` of the returned Buffer instance,\r\n * which defaults to __0__.\r\n *\r\n * ```\r\n * var buf = new Buffer('hello world');\r\n * var pointer = ref.alloc('pointer');\r\n *\r\n * var buf2 = ref.readPointer(pointer, 0, buf.length);\r\n * console.log(buf.toString());\r\n * 'hello world'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @param {Number} length (optional) The length of the returned Buffer. Defaults to 0.\r\n * @return {Buffer} The Buffer instance that was read from _buffer_.\r\n * @name readPointer\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a JavaScript String read from _buffer_ at the given _offset_. The\r\n * C String is read until the first NULL byte, which indicates the end of the\r\n * String.\r\n *\r\n * This function can read beyond the `length` of a Buffer.\r\n *\r\n * ```\r\n * var buf = new Buffer('hello\\0world\\0');\r\n *\r\n * var str = ref.readCString(buf, 0);\r\n * console.log(str);\r\n * 'hello'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {String} The String that was read from _buffer_.\r\n * @name readCString\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a big-endian signed 64-bit int read from _buffer_ at the given\r\n * _offset_.\r\n *\r\n * If the returned value will fit inside a JavaScript Number without losing\r\n * precision, then a Number is returned, otherwise a String is returned.\r\n *\r\n * ```\r\n * var buf = ref.alloc('int64');\r\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\r\n *\r\n * var val = ref.readInt64BE(buf, 0)\r\n * console.log(val)\r\n * '9223372036854775807'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {Number|String} The Number or String that was read from _buffer_.\r\n * @name readInt64BE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a little-endian signed 64-bit int read from _buffer_ at the given\r\n * _offset_.\r\n *\r\n * If the returned value will fit inside a JavaScript Number without losing\r\n * precision, then a Number is returned, otherwise a String is returned.\r\n *\r\n * ```\r\n * var buf = ref.alloc('int64');\r\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\r\n *\r\n * var val = ref.readInt64LE(buf, 0)\r\n * console.log(val)\r\n * '9223372036854775807'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {Number|String} The Number or String that was read from _buffer_.\r\n * @name readInt64LE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a big-endian unsigned 64-bit int read from _buffer_ at the given\r\n * _offset_.\r\n *\r\n * If the returned value will fit inside a JavaScript Number without losing\r\n * precision, then a Number is returned, otherwise a String is returned.\r\n *\r\n * ```\r\n * var buf = ref.alloc('uint64');\r\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\r\n *\r\n * var val = ref.readUInt64BE(buf, 0)\r\n * console.log(val)\r\n * '18446744073709551615'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {Number|String} The Number or String that was read from _buffer_.\r\n * @name readUInt64BE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a little-endian unsigned 64-bit int read from _buffer_ at the given\r\n * _offset_.\r\n *\r\n * If the returned value will fit inside a JavaScript Number without losing\r\n * precision, then a Number is returned, otherwise a String is returned.\r\n *\r\n * ```\r\n * var buf = ref.alloc('uint64');\r\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\r\n *\r\n * var val = ref.readUInt64LE(buf, 0)\r\n * console.log(val)\r\n * '18446744073709551615'\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to read a Buffer from.\r\n * @param {Number} offset The offset to begin reading from.\r\n * @return {Number|String} The Number or String that was read from _buffer_.\r\n * @name readUInt64LE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Writes the _input_ Number or String as a big-endian signed 64-bit int into\r\n * _buffer_ at the given _offset_.\r\n *\r\n * ```\r\n * var buf = ref.alloc('int64');\r\n * ref.writeInt64BE(buf, 0, '9223372036854775807');\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to write to.\r\n * @param {Number} offset The offset to begin writing from.\r\n * @param {Number|String} input This String or Number which gets written.\r\n * @name writeInt64BE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Writes the _input_ Number or String as a little-endian signed 64-bit int into\r\n * _buffer_ at the given _offset_.\r\n *\r\n * ```\r\n * var buf = ref.alloc('int64');\r\n * ref.writeInt64LE(buf, 0, '9223372036854775807');\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to write to.\r\n * @param {Number} offset The offset to begin writing from.\r\n * @param {Number|String} input This String or Number which gets written.\r\n * @name writeInt64LE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Writes the _input_ Number or String as a big-endian unsigned 64-bit int into\r\n * _buffer_ at the given _offset_.\r\n *\r\n * ```\r\n * var buf = ref.alloc('uint64');\r\n * ref.writeUInt64BE(buf, 0, '18446744073709551615');\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to write to.\r\n * @param {Number} offset The offset to begin writing from.\r\n * @param {Number|String} input This String or Number which gets written.\r\n * @name writeUInt64BE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Writes the _input_ Number or String as a little-endian unsigned 64-bit int\r\n * into _buffer_ at the given _offset_.\r\n *\r\n * ```\r\n * var buf = ref.alloc('uint64');\r\n * ref.writeUInt64LE(buf, 0, '18446744073709551615');\r\n * ```\r\n *\r\n * @param {Buffer} buffer The buffer to write to.\r\n * @param {Number} offset The offset to begin writing from.\r\n * @param {Number|String} input This String or Number which gets written.\r\n * @name writeUInt64LE\r\n * @type method\r\n */\r\n\r\n/**\r\n * Returns a new clone of the given \"type\" object, with its\r\n * `indirection` level incremented by **1**.\r\n *\r\n * Say you wanted to create a type representing a `void *`:\r\n *\r\n * ```\r\n * var voidPtrType = ref.refType(ref.types.void);\r\n * ```\r\n *\r\n * @param {Object|String} type The \"type\" object to create a reference type from. Strings get coerced first.\r\n * @return {Object} The new \"type\" object with its `indirection` incremented by 1.\r\n */\r\n\r\nexports.refType = function refType (type) {\r\n  var _type = exports.coerceType(type)\r\n  var rtn = Object.create(_type)\r\n  rtn.indirection++\r\n  if (_type.name) {\r\n    rtn.name = _type.name + '*'\r\n  }\r\n  return rtn\r\n}\r\n\r\n/**\r\n * Returns a new clone of the given \"type\" object, with its\r\n * `indirection` level decremented by 1.\r\n *\r\n * @param {Object|String} type The \"type\" object to create a dereference type from. Strings get coerced first.\r\n * @return {Object} The new \"type\" object with its `indirection` decremented by 1.\r\n */\r\n\r\nexports.derefType = function derefType (type) {\r\n  var _type = exports.coerceType(type)\r\n  if (_type.indirection === 1) {\r\n    throw new Error('Cannot create deref\\'d type for type with indirection 1')\r\n  }\r\n  var rtn = Object.getPrototypeOf(_type)\r\n  if (rtn.indirection !== _type.indirection - 1) {\r\n    // slow case\r\n    rtn = Object.create(_type)\r\n    rtn.indirection--\r\n  }\r\n  return rtn\r\n}\r\n\r\n/**\r\n * Coerces a \"type\" object from a String or an actual \"type\" object. String values\r\n * are looked up from the `ref.types` Object. So:\r\n *\r\n *   * `\"int\"` gets coerced into `ref.types.int`.\r\n *   * `\"int *\"` gets translated into `ref.refType(ref.types.int)`\r\n *   * `ref.types.int` gets translated into `ref.types.int` (returns itself)\r\n *\r\n * Throws an Error if no valid \"type\" object could be determined. Most `ref`\r\n * functions use this function under the hood, so anywhere a \"type\" object is\r\n * expected, a String may be passed as well, including simply setting the\r\n * `buffer.type` property.\r\n *\r\n * ```\r\n * var type = ref.coerceType('int **');\r\n *\r\n * console.log(type.indirection);\r\n * 3\r\n * ```\r\n *\r\n * @param {Object|String} type The \"type\" Object or String to coerce.\r\n * @return {Object} A \"type\" object\r\n */\r\n\r\nexports.coerceType = function coerceType (type) {\r\n  var rtn = type\r\n  if (typeof rtn === 'string') {\r\n    rtn = exports.types[type]\r\n    if (rtn) return rtn\r\n\r\n    // strip whitespace\r\n    rtn = type.replace(/\\s+/g, '').toLowerCase()\r\n    if (rtn === 'pointer') {\r\n      // legacy \"pointer\" being used :(\r\n      rtn = exports.refType(exports.types.void) // void *\r\n    } else if (rtn === 'string') {\r\n      rtn = exports.types.CString // special char * type\r\n    } else {\r\n      var refCount = 0\r\n      rtn = rtn.replace(/\\*/g, function () {\r\n        refCount++\r\n        return ''\r\n      })\r\n      // allow string names to be passed in\r\n      rtn = exports.types[rtn]\r\n      if (refCount > 0) {\r\n        if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\r\n          throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\r\n        }\r\n        for (var i = 0; i < refCount; i++) {\r\n          rtn = exports.refType(rtn)\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (!(rtn && 'size' in rtn && 'indirection' in rtn)) {\r\n    throw new TypeError('could not determine a proper \"type\" from: ' + JSON.stringify(type))\r\n  }\r\n  return rtn\r\n}\r\n\r\n/**\r\n * Returns the \"type\" property of the given Buffer.\r\n * Creates a default type for the buffer when none exists.\r\n *\r\n * @param {Buffer} buffer The Buffer instance to get the \"type\" object from.\r\n * @return {Object} The \"type\" object from the given Buffer.\r\n */\r\n\r\nexports.getType = function getType (buffer) {\r\n  if (!buffer.type) {\r\n    debug('WARN: no \"type\" found on buffer, setting default \"type\"', buffer)\r\n    buffer.type = {}\r\n    buffer.type.size = buffer.length\r\n    buffer.type.indirection = 1\r\n    buffer.type.get = function get () {\r\n      throw new Error('unknown \"type\"; cannot get()')\r\n    }\r\n    buffer.type.set = function set () {\r\n      throw new Error('unknown \"type\"; cannot set()')\r\n    }\r\n  }\r\n  return exports.coerceType(buffer.type)\r\n}\r\n\r\n/**\r\n * Calls the `get()` function of the Buffer's current \"type\" (or the\r\n * passed in _type_ if present) at the given _offset_.\r\n *\r\n * This function handles checking the \"indirection\" level and returning a\r\n * proper \"dereferenced\" Bufffer instance when necessary.\r\n *\r\n * @param {Buffer} buffer The Buffer instance to read from.\r\n * @param {Number} offset (optional) The offset on the Buffer to start reading from. Defaults to 0.\r\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\r\n * @return {?} Whatever value the \"type\" used when reading returns.\r\n */\r\n\r\nexports.get = function get (buffer, offset, type) {\r\n  if (!offset) {\r\n    offset = 0\r\n  }\r\n  if (type) {\r\n    type = exports.coerceType(type)\r\n  } else {\r\n    type = exports.getType(buffer)\r\n  }\r\n  debug('get(): (offset: %d)', offset, buffer)\r\n  assert(type.indirection > 0, '\"indirection\" level must be at least 1')\r\n  if (type.indirection === 1) {\r\n    // need to check \"type\"\r\n    return type.get(buffer, offset)\r\n  } else {\r\n    // need to create a deref'd Buffer\r\n    var size = type.indirection === 2 ? type.size : exports.sizeof.pointer\r\n    var reference = exports.readPointer(buffer, offset, size)\r\n    reference.type = exports.derefType(type)\r\n    return reference\r\n  }\r\n}\r\n\r\n/**\r\n * Calls the `set()` function of the Buffer's current \"type\" (or the\r\n * passed in _type_ if present) at the given _offset_.\r\n *\r\n * This function handles checking the \"indirection\" level writing a pointer rather\r\n * than calling the `set()` function if the indirection is greater than 1.\r\n *\r\n * @param {Buffer} buffer The Buffer instance to write to.\r\n * @param {Number} offset The offset on the Buffer to start writing to.\r\n * @param {?} value The value to write to the Buffer instance.\r\n * @param {Object|String} type (optional) The \"type\" object to use when reading. Defaults to calling `getType()` on the buffer.\r\n */\r\n\r\nexports.set = function set (buffer, offset, value, type) {\r\n  if (!offset) {\r\n    offset = 0\r\n  }\r\n  if (type) {\r\n    type = exports.coerceType(type)\r\n  } else {\r\n    type = exports.getType(buffer)\r\n  }\r\n  debug('set(): (offset: %d)', offset, buffer, value)\r\n  assert(type.indirection >= 1, '\"indirection\" level must be at least 1')\r\n  if (type.indirection === 1) {\r\n    type.set(buffer, offset, value)\r\n  } else {\r\n    exports.writePointer(buffer, offset, value)\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * Returns a new Buffer instance big enough to hold `type`,\r\n * with the given `value` written to it.\r\n *\r\n * ``` js\r\n * var intBuf = ref.alloc(ref.types.int)\r\n * var int_with_4 = ref.alloc(ref.types.int, 4)\r\n * ```\r\n *\r\n * @param {Object|String} type The \"type\" object to allocate. Strings get coerced first.\r\n * @param {?} value (optional) The initial value set on the returned Buffer, using _type_'s `set()` function.\r\n * @return {Buffer} A new Buffer instance with it's `type` set to \"type\", and (optionally) \"value\" written to it.\r\n */\r\n\r\nexports.alloc = function alloc (_type, value) {\r\n  var type = exports.coerceType(_type)\r\n  debug('allocating Buffer for type with \"size\"', type.size)\r\n  var size\r\n  if (type.indirection === 1) {\r\n    size = type.size\r\n  } else {\r\n    size = exports.sizeof.pointer\r\n  }\r\n  var buffer = new Buffer(size)\r\n  buffer.type = type\r\n  if (arguments.length >= 2) {\r\n    debug('setting value on allocated buffer', value)\r\n    exports.set(buffer, 0, value, type)\r\n  }\r\n  return buffer\r\n}\r\n\r\n/**\r\n * Returns a new `Buffer` instance with the given String written to it with the\r\n * given encoding (defaults to __'utf8'__). The buffer is 1 byte longer than the\r\n * string itself, and is NUL terminated.\r\n *\r\n * ```\r\n * var buf = ref.allocCString('hello world');\r\n *\r\n * console.log(buf.toString());\r\n * 'hello world\\u0000'\r\n * ```\r\n *\r\n * @param {String} string The JavaScript string to be converted to a C string.\r\n * @param {String} encoding (optional) The encoding to use for the C string. Defaults to __'utf8'__.\r\n * @return {Buffer} The new `Buffer` instance with the specified String wrtten to it, and a trailing NUL byte.\r\n */\r\n\r\nexports.allocCString = function allocCString (string, encoding) {\r\n  if (null == string || (Buffer.isBuffer(string) && exports.isNull(string))) {\r\n    return exports.NULL\r\n  }\r\n  var size = Buffer.byteLength(string, encoding) + 1\r\n  var buffer = new Buffer(size)\r\n  exports.writeCString(buffer, 0, string, encoding)\r\n  buffer.type = charPtrType\r\n  return buffer\r\n}\r\n\r\n/**\r\n * Writes the given string as a C String (NULL terminated) to the given buffer\r\n * at the given offset. \"encoding\" is optional and defaults to __'utf8'__.\r\n *\r\n * Unlike `readCString()`, this function requires the buffer to actually have the\r\n * proper length.\r\n *\r\n * @param {Buffer} buffer The Buffer instance to write to.\r\n * @param {Number} offset The offset of the buffer to begin writing at.\r\n * @param {String} string The JavaScript String to write that will be written to the buffer.\r\n * @param {String} encoding (optional) The encoding to read the C string as. Defaults to __'utf8'__.\r\n */\r\n\r\nexports.writeCString = function writeCString (buffer, offset, string, encoding) {\r\n  assert(Buffer.isBuffer(buffer), 'expected a Buffer as the first argument')\r\n  assert.equal('string', typeof string, 'expected a \"string\" as the third argument')\r\n  if (!offset) {\r\n    offset = 0\r\n  }\r\n  if (!encoding) {\r\n    encoding = 'utf8'\r\n  }\r\n  var size = buffer.length - offset\r\n  var len = buffer.write(string, offset, size, encoding)\r\n  buffer.writeUInt8(0, offset + len)  // NUL terminate\r\n}\r\n\r\nexports['readInt64' + exports.endianness] = exports.readInt64\r\nexports['readUInt64' + exports.endianness] = exports.readUInt64\r\nexports['writeInt64' + exports.endianness] = exports.writeInt64\r\nexports['writeUInt64' + exports.endianness] = exports.writeUInt64\r\n\r\nvar opposite = exports.endianness == 'LE' ? 'BE' : 'LE'\r\nvar int64temp = new Buffer(exports.sizeof.int64)\r\nvar uint64temp = new Buffer(exports.sizeof.uint64)\r\n\r\nexports['readInt64' + opposite] = function (buffer, offset) {\r\n  for (var i = 0; i < exports.sizeof.int64; i++) {\r\n    int64temp[i] = buffer[offset + exports.sizeof.int64 - i - 1]\r\n  }\r\n  return exports.readInt64(int64temp, 0)\r\n}\r\nexports['readUInt64' + opposite] = function (buffer, offset) {\r\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\r\n    uint64temp[i] = buffer[offset + exports.sizeof.uint64 - i - 1]\r\n  }\r\n  return exports.readUInt64(uint64temp, 0)\r\n}\r\nexports['writeInt64' + opposite] = function (buffer, offset, value) {\r\n  exports.writeInt64(int64temp, 0, value)\r\n  for (var i = 0; i < exports.sizeof.int64; i++) {\r\n    buffer[offset + i] = int64temp[exports.sizeof.int64 - i - 1]\r\n  }\r\n}\r\nexports['writeUInt64' + opposite] = function (buffer, offset, value) {\r\n  exports.writeUInt64(uint64temp, 0, value)\r\n  for (var i = 0; i < exports.sizeof.uint64; i++) {\r\n    buffer[offset + i] = uint64temp[exports.sizeof.uint64 - i - 1]\r\n  }\r\n}\r\n\r\n/**\r\n * `ref()` accepts a Buffer instance and returns a new Buffer\r\n * instance that is \"pointer\" sized and has its data pointing to the given\r\n * Buffer instance. Essentially the created Buffer is a \"reference\" to the\r\n * original pointer, equivalent to the following C code:\r\n *\r\n * ``` c\r\n * char *buf = buffer;\r\n * char **ref = &buf;\r\n * ```\r\n *\r\n * @param {Buffer} buffer A Buffer instance to create a reference to.\r\n * @return {Buffer} A new Buffer instance pointing to _buffer_.\r\n */\r\n\r\nexports.ref = function ref (buffer) {\r\n  debug('creating a reference to buffer', buffer)\r\n  var type = exports.refType(exports.getType(buffer))\r\n  return exports.alloc(type, buffer)\r\n}\r\n\r\n/**\r\n * Accepts a Buffer instance and attempts to \"dereference\" it.\r\n * That is, first it checks the `indirection` count of _buffer_'s \"type\", and if\r\n * it's greater than __1__ then it merely returns another Buffer, but with one\r\n * level less `indirection`.\r\n *\r\n * When _buffer_'s indirection is at __1__, then it checks for `buffer.type`\r\n * which should be an Object with its own `get()` function.\r\n *\r\n * ```\r\n * var buf = ref.alloc('int', 6);\r\n *\r\n * var val = ref.deref(buf);\r\n * console.log(val);\r\n * 6\r\n * ```\r\n *\r\n *\r\n * @param {Buffer} buffer A Buffer instance to dereference.\r\n * @return {?} The returned value after dereferencing _buffer_.\r\n */\r\n\r\nexports.deref = function deref (buffer) {\r\n  debug('dereferencing buffer', buffer)\r\n  return exports.get(buffer)\r\n}\r\n\r\n/**\r\n * Attaches _object_ to _buffer_ such that it prevents _object_ from being garbage\r\n * collected until _buffer_ does.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to attach _object_ to.\r\n * @param {Object|Buffer} object An Object or Buffer to prevent from being garbage collected until _buffer_ does.\r\n * @api private\r\n */\r\n\r\nexports._attach = function _attach (buf, obj) {\r\n  if (!buf._refs) {\r\n    buf._refs = []\r\n  }\r\n  buf._refs.push(obj)\r\n}\r\n\r\n/**\r\n * Same as `ref.writeObject()`, except that this version does not _attach_ the\r\n * Object to the Buffer, which is potentially unsafe if the garbage collector\r\n * runs.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\r\n * @param {Number} offset The offset on the Buffer to start writing at.\r\n * @param {Object} object The Object to be written into _buffer_.\r\n * @api private\r\n */\r\n\r\nexports._writeObject = exports.writeObject\r\n\r\n/**\r\n * Writes a pointer to _object_ into _buffer_ at the specified _offset.\r\n *\r\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\r\n * collected.\r\n *\r\n * ```\r\n * var buf = ref.alloc('Object');\r\n * ref.writeObject(buf, 0, { foo: 'bar' });\r\n *\r\n * ```\r\n *\r\n * @param {Buffer} buffer A Buffer instance to write _object_ to.\r\n * @param {Number} offset The offset on the Buffer to start writing at.\r\n * @param {Object} object The Object to be written into _buffer_.\r\n */\r\n\r\nexports.writeObject = function writeObject (buf, offset, obj, persistent) {\r\n  debug('writing Object to buffer', buf, offset, obj, persistent)\r\n  exports._writeObject(buf, offset, obj, persistent)\r\n  exports._attach(buf, obj)\r\n}\r\n\r\n/**\r\n * Same as `ref.writePointer()`, except that this version does not attach\r\n * _pointer_ to _buffer_, which is potentially unsafe if the garbage collector\r\n * runs.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\r\n * @param {Number} offset The offset on the Buffer to start writing at.\r\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\r\n * @api private\r\n */\r\n\r\nexports._writePointer = exports.writePointer\r\n\r\n/**\r\n * Writes the memory address of _pointer_ to _buffer_ at the specified _offset_.\r\n *\r\n * This function \"attaches\" _object_ to _buffer_ to prevent it from being garbage\r\n * collected.\r\n *\r\n * ```\r\n * var someBuffer = new Buffer('whatever');\r\n * var buf = ref.alloc('pointer');\r\n * ref.writePointer(buf, 0, someBuffer);\r\n * ```\r\n *\r\n * @param {Buffer} buffer A Buffer instance to write _pointer to.\r\n * @param {Number} offset The offset on the Buffer to start writing at.\r\n * @param {Buffer} pointer The Buffer instance whose memory address will be written to _buffer_.\r\n */\r\n\r\nexports.writePointer = function writePointer (buf, offset, ptr) {\r\n  debug('writing pointer to buffer', buf, offset, ptr)\r\n  exports._writePointer(buf, offset, ptr)\r\n  exports._attach(buf, ptr)\r\n}\r\n\r\n/**\r\n * Same as `ref.reinterpret()`, except that this version does not attach\r\n * _buffer_ to the returned Buffer, which is potentially unsafe if the\r\n * garbage collector runs.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\r\n * @param {Number} size The `length` property of the returned Buffer.\r\n * @param {Number} offset The offset of the Buffer to begin from.\r\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\r\n * @api private\r\n */\r\n\r\nexports._reinterpret = exports.reinterpret\r\n\r\n/**\r\n * Returns a new Buffer instance with the specified _size_, with the same memory\r\n * address as _buffer_.\r\n *\r\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\r\n * being garbage collected.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\r\n * @param {Number} size The `length` property of the returned Buffer.\r\n * @param {Number} offset The offset of the Buffer to begin from.\r\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and the requested _size_.\r\n */\r\n\r\nexports.reinterpret = function reinterpret (buffer, size, offset) {\r\n  debug('reinterpreting buffer to \"%d\" bytes', size)\r\n  var rtn = exports._reinterpret(buffer, size, offset || 0)\r\n  exports._attach(rtn, buffer)\r\n  return rtn\r\n}\r\n\r\n/**\r\n * Same as `ref.reinterpretUntilZeros()`, except that this version does not\r\n * attach _buffer_ to the returned Buffer, which is potentially unsafe if the\r\n * garbage collector runs.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\r\n * @param {Number} size The number of sequential, aligned `NULL` bytes that are required to terminate the buffer.\r\n * @param {Number} offset The offset of the Buffer to begin from.\r\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\r\n * @api private\r\n */\r\n\r\nexports._reinterpretUntilZeros = exports.reinterpretUntilZeros\r\n\r\n/**\r\n * Accepts a `Buffer` instance and a number of `NULL` bytes to read from the\r\n * pointer. This function will scan past the boundary of the Buffer's `length`\r\n * until it finds `size` number of aligned `NULL` bytes.\r\n *\r\n * This is useful for finding the end of NUL-termintated array or C string. For\r\n * example, the `readCString()` function _could_ be implemented like:\r\n *\r\n * ```\r\n * function readCString (buf) {\r\n *   return ref.reinterpretUntilZeros(buf, 1).toString('utf8')\r\n * }\r\n * ```\r\n *\r\n * This function \"attaches\" _buffer_ to the returned Buffer to prevent it from\r\n * being garbage collected.\r\n *\r\n * @param {Buffer} buffer A Buffer instance to base the returned Buffer off of.\r\n * @param {Number} size The number of sequential, aligned `NULL` bytes are required to terminate the buffer.\r\n * @param {Number} offset The offset of the Buffer to begin from.\r\n * @return {Buffer} A new Buffer instance with the same memory address as _buffer_, and a variable `length` that is terminated by _size_ NUL bytes.\r\n */\r\n\r\nexports.reinterpretUntilZeros = function reinterpretUntilZeros (buffer, size, offset) {\r\n  debug('reinterpreting buffer to until \"%d\" NULL (0) bytes are found', size)\r\n  var rtn = exports._reinterpretUntilZeros(buffer, size, offset || 0)\r\n  exports._attach(rtn, buffer)\r\n  return rtn\r\n}\r\n\r\n\r\n// the built-in \"types\"\r\nvar types = exports.types = {}\r\n\r\n/**\r\n * The `void` type.\r\n *\r\n * @section types\r\n */\r\n\r\ntypes.void = {\r\n    size: 0\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      debug('getting `void` type (returns `null`)')\r\n      return null\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      debug('setting `void` type (no-op)')\r\n    }\r\n}\r\n\r\n/**\r\n * The `int8` type.\r\n */\r\n\r\ntypes.int8 = {\r\n    size: exports.sizeof.int8\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf.readInt8(offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      if (typeof val === 'string') {\r\n        val = val.charCodeAt(0)\r\n      }\r\n      return buf.writeInt8(val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `uint8` type.\r\n */\r\n\r\ntypes.uint8 = {\r\n    size: exports.sizeof.uint8\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf.readUInt8(offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      if (typeof val === 'string') {\r\n        val = val.charCodeAt(0)\r\n      }\r\n      return buf.writeUInt8(val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `int16` type.\r\n */\r\n\r\ntypes.int16 = {\r\n    size: exports.sizeof.int16\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readInt16' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeInt16' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `uint16` type.\r\n */\r\n\r\ntypes.uint16 = {\r\n    size: exports.sizeof.uint16\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readUInt16' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeUInt16' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `int32` type.\r\n */\r\n\r\ntypes.int32 = {\r\n    size: exports.sizeof.int32\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readInt32' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeInt32' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `uint32` type.\r\n */\r\n\r\ntypes.uint32 = {\r\n    size: exports.sizeof.uint32\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readUInt32' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeUInt32' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `int64` type.\r\n */\r\n\r\ntypes.int64 = {\r\n    size: exports.sizeof.int64\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readInt64' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeInt64' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `uint64` type.\r\n */\r\n\r\ntypes.uint64 = {\r\n    size: exports.sizeof.uint64\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readUInt64' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeUInt64' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `float` type.\r\n */\r\n\r\ntypes.float = {\r\n    size: exports.sizeof.float\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readFloat' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeFloat' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `double` type.\r\n */\r\n\r\ntypes.double = {\r\n    size: exports.sizeof.double\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf['readDouble' + exports.endianness](offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf['writeDouble' + exports.endianness](val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `Object` type. This can be used to read/write regular JS Objects\r\n * into raw memory.\r\n */\r\n\r\ntypes.Object = {\r\n    size: exports.sizeof.Object\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      return buf.readObject(offset || 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      return buf.writeObject(val, offset || 0)\r\n    }\r\n}\r\n\r\n/**\r\n * The `CString` (a.k.a `\"string\"`) type.\r\n *\r\n * CStrings are a kind of weird thing. We say it's `sizeof(char *)`, and\r\n * `indirection` level of 1, which means that we have to return a Buffer that\r\n * is pointer sized, and points to a some utf8 string data, so we have to create\r\n * a 2nd \"in-between\" buffer.\r\n */\r\n\r\ntypes.CString = {\r\n    size: exports.sizeof.pointer\r\n  , alignment: exports.alignof.pointer\r\n  , indirection: 1\r\n  , get: function get (buf, offset) {\r\n      var _buf = exports.readPointer(buf, offset)\r\n      if (exports.isNull(_buf)) {\r\n        return null\r\n      }\r\n      return exports.readCString(_buf, 0)\r\n    }\r\n  , set: function set (buf, offset, val) {\r\n      var _buf\r\n      if (Buffer.isBuffer(val)) {\r\n        _buf = val\r\n      } else {\r\n        // assume string\r\n        _buf = exports.allocCString(val)\r\n      }\r\n      return exports.writePointer(buf, offset, _buf)\r\n    }\r\n}\r\n\r\n// alias Utf8String\r\nvar utfstringwarned = false\r\nObject.defineProperty(types, 'Utf8String', {\r\n    enumerable: false\r\n  , configurable: true\r\n  , get: function () {\r\n      if (!utfstringwarned) {\r\n        utfstringwarned = true\r\n        console.error('\"Utf8String\" type is deprecated, use \"CString\" instead')\r\n      }\r\n      return types.CString\r\n    }\r\n})\r\n\r\n/**\r\n * The `bool` type.\r\n *\r\n * Wrapper type around `types.uint8` that accepts/returns `true` or\r\n * `false` Boolean JavaScript values.\r\n *\r\n * @name bool\r\n *\r\n */\r\n\r\n/**\r\n * The `byte` type.\r\n *\r\n * @name byte\r\n */\r\n\r\n/**\r\n * The `char` type.\r\n *\r\n * @name char\r\n */\r\n\r\n/**\r\n * The `uchar` type.\r\n *\r\n * @name uchar\r\n */\r\n\r\n/**\r\n * The `short` type.\r\n *\r\n * @name short\r\n */\r\n\r\n/**\r\n * The `ushort` type.\r\n *\r\n * @name ushort\r\n */\r\n\r\n/**\r\n * The `int` type.\r\n *\r\n * @name int\r\n */\r\n\r\n/**\r\n * The `uint` type.\r\n *\r\n * @name uint\r\n */\r\n\r\n/**\r\n * The `long` type.\r\n *\r\n * @name long\r\n */\r\n\r\n/**\r\n * The `ulong` type.\r\n *\r\n * @name ulong\r\n */\r\n\r\n/**\r\n * The `longlong` type.\r\n *\r\n * @name longlong\r\n */\r\n\r\n/**\r\n * The `ulonglong` type.\r\n *\r\n * @name ulonglong\r\n */\r\n\r\n/**\r\n * The `size_t` type.\r\n *\r\n * @name size_t\r\n */\r\n\r\n// \"typedef\"s for the variable-sized types\r\n;[ 'bool', 'byte', 'char', 'uchar', 'short', 'ushort', 'int', 'uint', 'long'\r\n, 'ulong', 'longlong', 'ulonglong', 'size_t' ].forEach(function (name) {\r\n  var unsigned = name === 'bool'\r\n              || name === 'byte'\r\n              || name === 'size_t'\r\n              || name[0] === 'u'\r\n  var size = exports.sizeof[name]\r\n  assert(size >= 1 && size <= 8)\r\n  var typeName = 'int' + (size * 8)\r\n  if (unsigned) {\r\n    typeName = 'u' + typeName\r\n  }\r\n  var type = exports.types[typeName]\r\n  assert(type)\r\n  exports.types[name] = Object.create(type)\r\n})\r\n\r\n// set the \"alignment\" property on the built-in types\r\nObject.keys(exports.alignof).forEach(function (name) {\r\n  if (name === 'pointer') return\r\n  exports.types[name].alignment = exports.alignof[name]\r\n  assert(exports.types[name].alignment > 0)\r\n})\r\n\r\n// make the `bool` type work with JS true/false values\r\nexports.types.bool.get = (function (_get) {\r\n  return function get (buf, offset) {\r\n    return _get(buf, offset) ? true : false\r\n  }\r\n})(exports.types.bool.get)\r\nexports.types.bool.set = (function (_set) {\r\n  return function set (buf, offset, val) {\r\n    if (typeof val !== 'number') {\r\n      val = val ? 1 : 0\r\n    }\r\n    return _set(buf, offset, val)\r\n  }\r\n})(exports.types.bool.set)\r\n\r\n/*!\r\n * Set the `name` property of the types. Used for debugging...\r\n */\r\n\r\nObject.keys(exports.types).forEach(function (name) {\r\n  exports.types[name].name = name\r\n})\r\n\r\n/*!\r\n * This `char *` type is used by \"allocCString()\" above.\r\n */\r\n\r\nvar charPtrType = exports.refType(exports.types.char)\r\n\r\n/*!\r\n * Set the `type` property of the `NULL` pointer Buffer object.\r\n */\r\n\r\nexports.NULL.type = exports.types.void\r\n\r\n/**\r\n * `NULL_POINTER` is a pointer-sized `Buffer` instance pointing to `NULL`.\r\n * Conceptually, it's equivalent to the following C code:\r\n *\r\n * ``` c\r\n * char *null_pointer;\r\n * null_pointer = NULL;\r\n * ```\r\n *\r\n * @type Buffer\r\n */\r\n\r\nexports.NULL_POINTER = exports.ref(exports.NULL)\r\n\r\n/**\r\n * All these '...' comment blocks below are for the documentation generator.\r\n *\r\n * @section buffer\r\n */\r\n\r\nBuffer.prototype.address = function address () {\r\n  return exports.address(this, 0)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.hexAddress = function hexAddress () {\r\n  return exports.hexAddress(this, 0)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.isNull = function isNull () {\r\n  return exports.isNull(this, 0)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.ref = function ref () {\r\n  return exports.ref(this)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.deref = function deref () {\r\n  return exports.deref(this)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readObject = function readObject (offset) {\r\n  return exports.readObject(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeObject = function writeObject (obj, offset) {\r\n  return exports.writeObject(this, offset, obj)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readPointer = function readPointer (offset, size) {\r\n  return exports.readPointer(this, offset, size)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writePointer = function writePointer (ptr, offset) {\r\n  return exports.writePointer(this, offset, ptr)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readCString = function readCString (offset) {\r\n  return exports.readCString(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeCString = function writeCString (string, offset, encoding) {\r\n  return exports.writeCString(this, offset, string, encoding)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readInt64BE = function readInt64BE (offset) {\r\n  return exports.readInt64BE(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeInt64BE = function writeInt64BE (val, offset) {\r\n  return exports.writeInt64BE(this, offset, val)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readUInt64BE = function readUInt64BE (offset) {\r\n  return exports.readUInt64BE(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeUInt64BE = function writeUInt64BE (val, offset) {\r\n  return exports.writeUInt64BE(this, offset, val)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readInt64LE = function readInt64LE (offset) {\r\n  return exports.readInt64LE(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeInt64LE = function writeInt64LE (val, offset) {\r\n  return exports.writeInt64LE(this, offset, val)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.readUInt64LE = function readUInt64LE (offset) {\r\n  return exports.readUInt64LE(this, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.writeUInt64LE = function writeUInt64LE (val, offset) {\r\n  return exports.writeUInt64LE(this, offset, val)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.reinterpret = function reinterpret (size, offset) {\r\n  return exports.reinterpret(this, size, offset)\r\n}\r\n\r\n/**\r\n * ...\r\n */\r\n\r\nBuffer.prototype.reinterpretUntilZeros = function reinterpretUntilZeros (size, offset) {\r\n  return exports.reinterpretUntilZeros(this, size, offset)\r\n}\r\n\r\n/**\r\n * `ref` overwrites the default `Buffer#inspect()` function to include the\r\n * hex-encoded memory address of the Buffer instance when invoked.\r\n *\r\n * This is simply a nice-to-have.\r\n *\r\n * **Before**:\r\n *\r\n * ``` js\r\n * console.log(new Buffer('ref'));\r\n * <Buffer 72 65 66>\r\n * ```\r\n *\r\n * **After**:\r\n *\r\n * ``` js\r\n * console.log(new Buffer('ref'));\r\n * <Buffer@0x103015490 72 65 66>\r\n * ```\r\n */\r\n\r\nBuffer.prototype.inspect = overwriteInspect(Buffer.prototype.inspect)\r\n\r\n// does SlowBuffer inherit from Buffer? (node >= v0.7.9)\r\nif (!(exports.NULL instanceof Buffer)) {\r\n  debug('extending SlowBuffer\\'s prototype since it doesn\\'t inherit from Buffer.prototype')\r\n\r\n  /*!\r\n   * SlowBuffer convenience methods.\r\n   */\r\n\r\n  var SlowBuffer = require('buffer').SlowBuffer\r\n\r\n  SlowBuffer.prototype.address = Buffer.prototype.address\r\n  SlowBuffer.prototype.hexAddress = Buffer.prototype.hexAddress\r\n  SlowBuffer.prototype.isNull = Buffer.prototype.isNull\r\n  SlowBuffer.prototype.ref = Buffer.prototype.ref\r\n  SlowBuffer.prototype.deref = Buffer.prototype.deref\r\n  SlowBuffer.prototype.readObject = Buffer.prototype.readObject\r\n  SlowBuffer.prototype.writeObject = Buffer.prototype.writeObject\r\n  SlowBuffer.prototype.readPointer = Buffer.prototype.readPointer\r\n  SlowBuffer.prototype.writePointer = Buffer.prototype.writePointer\r\n  SlowBuffer.prototype.readCString = Buffer.prototype.readCString\r\n  SlowBuffer.prototype.writeCString = Buffer.prototype.writeCString\r\n  SlowBuffer.prototype.reinterpret = Buffer.prototype.reinterpret\r\n  SlowBuffer.prototype.reinterpretUntilZeros = Buffer.prototype.reinterpretUntilZeros\r\n  SlowBuffer.prototype.readInt64BE = Buffer.prototype.readInt64BE\r\n  SlowBuffer.prototype.writeInt64BE = Buffer.prototype.writeInt64BE\r\n  SlowBuffer.prototype.readUInt64BE = Buffer.prototype.readUInt64BE\r\n  SlowBuffer.prototype.writeUInt64BE = Buffer.prototype.writeUInt64BE\r\n  SlowBuffer.prototype.readInt64LE = Buffer.prototype.readInt64LE\r\n  SlowBuffer.prototype.writeInt64LE = Buffer.prototype.writeInt64LE\r\n  SlowBuffer.prototype.readUInt64LE = Buffer.prototype.readUInt64LE\r\n  SlowBuffer.prototype.writeUInt64LE = Buffer.prototype.writeUInt64LE\r\n  SlowBuffer.prototype.inspect = overwriteInspect(SlowBuffer.prototype.inspect)\r\n}\r\n\r\nfunction overwriteInspect (inspect) {\r\n  if (inspect.name === 'refinspect') {\r\n    return inspect\r\n  } else {\r\n    return function refinspect () {\r\n      var v = inspect.apply(this, arguments)\r\n      return v.replace('Buffer', 'Buffer@0x' + this.hexAddress())\r\n    }\r\n  }\r\n}\r\n"]}