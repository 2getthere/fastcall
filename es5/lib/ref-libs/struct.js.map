{"version":3,"sources":["../../../lib/ref-libs/struct.js"],"names":["ref","require","util","assert","debug","module","exports","Struct","StructType","arg","data","store","Buffer","isBuffer","length","size","type","key","_instanceCreated","prototype","Object","create","proto","constructor","value","enumerable","writable","configurable","defineProperty","toString","fields","opt","arguments","alignment","indirection","isPacked","packed","Boolean","get","set","Array","isArray","forEach","a","name","keys","buffer","offset","slice","isStruct","copy","coerceType","equal","test","field","cacheName","desc","got","recalc","struct","fieldNames","alignof","pointer","Math","min","max","fixedLength","addType","i","align","padding","sizeof","left","NULL","toObject","obj","k","toJSON","inspect"],"mappings":"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","file":"struct.js","sourcesContent":["\r\n/**\r\n * An interface for modeling and instantiating C-style data structures. This is\r\n * not a constructor per-say, but a constructor generator. It takes an array of\r\n * tuples, the left side being the type, and the right side being a field name.\r\n * The order should be the same order it would appear in the C-style struct\r\n * definition. It returns a function that can be used to construct an object that\r\n * reads and writes to the data structure using properties specified by the\r\n * initial field list.\r\n *\r\n * The only verboten field names are \"ref\", which is used used on struct\r\n * instances as a function to retrieve the backing Buffer instance of the\r\n * struct, and \"ref.buffer\" which contains the backing Buffer instance.\r\n *\r\n *\r\n * Example:\r\n *\r\n * ``` javascript\r\n * var ref = require('ref')\r\n * var Struct = require('ref-struct')\r\n *\r\n * // create the `char *` type\r\n * var charPtr = ref.refType(ref.types.char)\r\n * var int = ref.types.int\r\n *\r\n * // create the struct \"type\" / constructor\r\n * var PasswordEntry = Struct({\r\n *     'username': 'string'\r\n *   , 'password': 'string'\r\n *   , 'salt':     int\r\n * })\r\n *\r\n * // create an instance of the struct, backed a Buffer instance\r\n * var pwd = new PasswordEntry()\r\n * pwd.username = 'ricky'\r\n * pwd.password = 'rbransonlovesnode.js'\r\n * pwd.salt = (Math.random() * 1000000) | 0\r\n *\r\n * pwd.username // → 'ricky'\r\n * pwd.password // → 'rbransonlovesnode.js'\r\n * pwd.salt     // → 820088\r\n * ```\r\n */\r\n\r\n/**\r\n * Module dependencies.\r\n */\r\n\r\nvar ref = require('./ref')\r\nvar util = require('util')\r\nvar assert = require('assert')\r\nvar debug = require('debug')('ref:struct')\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = Struct\r\n\r\n/**\r\n * The Struct \"type\" meta-constructor.\r\n */\r\n\r\nfunction Struct () {\r\n  debug('defining new struct \"type\"')\r\n\r\n  /**\r\n   * This is the \"constructor\" of the Struct type that gets returned.\r\n   *\r\n   * Invoke it with `new` to create a new Buffer instance backing the struct.\r\n   * Pass it an existing Buffer instance to use that as the backing buffer.\r\n   * Pass in an Object containing the struct fields to auto-populate the\r\n   * struct with the data.\r\n   */\r\n\r\n  function StructType (arg, data) {\r\n    if (!(this instanceof StructType)) {\r\n      return new StructType(arg, data)\r\n    }\r\n    debug('creating new struct instance')\r\n    var store\r\n    if (Buffer.isBuffer(arg)) {\r\n      debug('using passed-in Buffer instance to back the struct', arg)\r\n      assert(arg.length >= StructType.size, 'Buffer instance must be at least ' +\r\n          StructType.size + ' bytes to back this struct type')\r\n      store = arg\r\n      arg = data\r\n    } else {\r\n      debug('creating new Buffer instance to back the struct (size: %d)', StructType.size)\r\n      store = new Buffer(StructType.size)\r\n    }\r\n\r\n    // set the backing Buffer store\r\n    store.type = StructType\r\n    this['ref.buffer'] = store\r\n\r\n    if (arg) {\r\n      for (var key in arg) {\r\n        // hopefully hit the struct setters\r\n        this[key] = arg[key]\r\n      }\r\n    }\r\n    StructType._instanceCreated = true\r\n  }\r\n\r\n  // make instances inherit from the `proto`\r\n  StructType.prototype = Object.create(proto, {\r\n    constructor: {\r\n        value: StructType\r\n      , enumerable: false\r\n      , writable: true\r\n      , configurable: true\r\n    }\r\n  })\r\n\r\n  StructType.defineProperty = defineProperty\r\n  StructType.toString = toString\r\n  StructType.fields = {}\r\n\r\n  var opt = (arguments.length > 0 && arguments[1]) ? arguments[1] : {};\r\n  // Setup the ref \"type\" interface. The constructor doubles as the \"type\" object\r\n  StructType.size = 0\r\n  StructType.alignment = 0\r\n  StructType.indirection = 1\r\n  StructType.isPacked = opt.packed ? Boolean(opt.packed) : false\r\n  StructType.get = get\r\n  StructType.set = set\r\n\r\n  // Read the fields list and apply all the fields to the struct\r\n  // TODO: Better arg handling... (maybe look at ES6 binary data API?)\r\n  var arg = arguments[0]\r\n  if (Array.isArray(arg)) {\r\n    // legacy API\r\n    arg.forEach(function (a) {\r\n      var type = a[0]\r\n      var name = a[1]\r\n      StructType.defineProperty(name, type)\r\n    })\r\n  } else if (typeof arg === 'object') {\r\n    Object.keys(arg).forEach(function (name) {\r\n      var type = arg[name]\r\n      StructType.defineProperty(name, type)\r\n    })\r\n  }\r\n\r\n  return StructType\r\n}\r\n\r\n/**\r\n * The \"get\" function of the Struct \"type\" interface\r\n */\r\n\r\nfunction get (buffer, offset) {\r\n  debug('Struct \"type\" getter for buffer at offset', buffer, offset)\r\n  if (offset > 0) {\r\n    buffer = buffer.slice(offset)\r\n  }\r\n  return new this(buffer)\r\n}\r\n\r\n/**\r\n * The \"set\" function of the Struct \"type\" interface\r\n */\r\n\r\nfunction set (buffer, offset, value) {\r\n  debug('Struct \"type\" setter for buffer at offset', buffer, offset, value)\r\n  var isStruct = value instanceof this\r\n  if (isStruct) {\r\n    // optimization: copy the buffer contents directly rather\r\n    // than going through the ref-struct constructor\r\n    value['ref.buffer'].copy(buffer, offset, 0, this.size)\r\n  } else {\r\n    if (offset > 0) {\r\n      buffer = buffer.slice(offset)\r\n    }\r\n    new this(buffer, value)\r\n  }\r\n}\r\n\r\n/**\r\n * Custom `toString()` override for struct type instances.\r\n */\r\n\r\nfunction toString () {\r\n  return '[StructType]'\r\n}\r\n\r\n/**\r\n * Adds a new field to the struct instance with the given name and type.\r\n * Note that this function will throw an Error if any instances of the struct\r\n * type have already been created, therefore this function must be called at the\r\n * beginning, before any instances are created.\r\n */\r\n\r\nfunction defineProperty (name, type) {\r\n  debug('defining new struct type field', name)\r\n\r\n  // allow string types for convenience\r\n  type = ref.coerceType(type)\r\n\r\n  assert(!this._instanceCreated, 'an instance of this Struct type has already ' +\r\n      'been created, cannot add new \"fields\" anymore')\r\n  assert.equal('string', typeof name, 'expected a \"string\" field name')\r\n  assert(type && /object|function/i.test(typeof type) && 'size' in type &&\r\n      'indirection' in type\r\n      , 'expected a \"type\" object describing the field type: \"' + type + '\"')\r\n  assert(type.indirection > 1 || type.size > 0,\r\n      '\"type\" object must have a size greater than 0')\r\n  assert(!(name in this.prototype), 'the field \"' + name +\r\n      '\" already exists in this Struct type')\r\n\r\n  var field = {\r\n    type: type\r\n  }\r\n  this.fields[name] = field\r\n  var cacheName = '_cache' + name\r\n\r\n  // define the getter/setter property\r\n  var desc = { enumerable: true , configurable: true }\r\n  desc.get = function () {\r\n    if (this[cacheName]) {\r\n      return this[cacheName]\r\n    }\r\n    debug('getting \"%s\" struct field (offset: %d)', name, field.offset)\r\n    var got = ref.get(this['ref.buffer'], field.offset, type)\r\n    if (typeof got === 'object') {\r\n      this[cacheName] = got;\r\n    }\r\n    return got;\r\n  }\r\n  desc.set = function (value) {\r\n    this[cacheName] = null\r\n    debug('setting \"%s\" struct field (offset: %d)', name, field.offset, value)\r\n    return ref.set(this['ref.buffer'], field.offset, value, type)\r\n  }\r\n\r\n  // calculate the new size and field offsets\r\n  recalc(this)\r\n\r\n  Object.defineProperty(this.prototype, name, desc)\r\n}\r\n\r\nfunction recalc (struct) {\r\n\r\n  // reset size and alignment\r\n  struct.size = 0\r\n  struct.alignment = 0\r\n\r\n  var fieldNames = Object.keys(struct.fields)\r\n\r\n  // first loop through is to determine the `alignment` of this struct\r\n  fieldNames.forEach(function (name) {\r\n    var field = struct.fields[name]\r\n    var type = field.type\r\n    var alignment = type.alignment || ref.alignof.pointer\r\n    if (type.indirection > 1) {\r\n      alignment = ref.alignof.pointer\r\n    }\r\n    if (struct.isPacked) {\r\n      struct.alignment = Math.min(struct.alignment || alignment, alignment)\r\n    } else {\r\n      struct.alignment = Math.max(struct.alignment, alignment)\r\n    }\r\n  })\r\n\r\n  // second loop through sets the `offset` property on each \"field\"\r\n  // object, and sets the `struct.size` as we go along\r\n  fieldNames.forEach(function (name) {\r\n    var field = struct.fields[name]\r\n    var type = field.type\r\n\r\n    if (null != type.fixedLength) {\r\n      // \"ref-array\" types set the \"fixedLength\" prop. don't treat arrays like one\r\n      // contiguous entity. instead, treat them like individual elements in the\r\n      // struct. doing this makes the padding end up being calculated correctly.\r\n      field.offset = addType(type.type)\r\n      for (var i = 1; i < type.fixedLength; i++) {\r\n        addType(type.type)\r\n      }\r\n    } else {\r\n      field.offset = addType(type)\r\n    }\r\n  })\r\n\r\n  function addType (type) {\r\n    var offset = struct.size\r\n    var align = type.indirection === 1 ? type.alignment : ref.alignof.pointer\r\n    var padding = struct.isPacked ? 0 : (align - (offset % align)) % align\r\n    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer\r\n\r\n    offset += padding\r\n\r\n    if (!struct.isPacked) {\r\n      assert.equal(offset % align, 0, \"offset should align\")\r\n    }\r\n\r\n    // adjust the \"size\" of the struct type\r\n    struct.size = offset + size\r\n\r\n    // return the calulated offset\r\n    return offset\r\n  }\r\n\r\n  // any final padding?\r\n  var left = struct.size % struct.alignment\r\n  if (left > 0) {\r\n    debug('additional padding to the end of struct:', struct.alignment - left)\r\n    struct.size += struct.alignment - left\r\n  }\r\n}\r\n\r\n/**\r\n * this is the custom prototype of Struct type instances.\r\n */\r\n\r\nvar proto = {}\r\n\r\n/**\r\n * set a placeholder variable on the prototype so that defineProperty() will\r\n * throw an error if you try to define a struct field with the name \"buffer\".\r\n */\r\n\r\nproto['ref.buffer'] = ref.NULL\r\n\r\n/**\r\n * Flattens the Struct instance into a regular JavaScript Object. This function\r\n * \"gets\" all the defined properties.\r\n *\r\n * @api public\r\n */\r\n\r\nproto.toObject = function toObject () {\r\n  var obj = {}\r\n  Object.keys(this.constructor.fields).forEach(function (k) {\r\n    obj[k] = this[k]\r\n  }, this)\r\n  return obj\r\n}\r\n\r\n/**\r\n * Basic `JSON.stringify(struct)` support.\r\n */\r\n\r\nproto.toJSON = function toJSON () {\r\n  return this.toObject()\r\n}\r\n\r\n/**\r\n * `.inspect()` override. For the REPL.\r\n *\r\n * @api public\r\n */\r\n\r\nproto.inspect = function inspect () {\r\n  var obj = this.toObject()\r\n  // add instance's \"own properties\"\r\n  Object.keys(this).forEach(function (k) {\r\n    obj[k] = this[k]\r\n  }, this)\r\n  return util.inspect(obj)\r\n}\r\n\r\n/**\r\n * returns a Buffer pointing to this struct data structure.\r\n */\r\n\r\nproto.ref = function ref () {\r\n  return this['ref.buffer']\r\n}\r\n"]}