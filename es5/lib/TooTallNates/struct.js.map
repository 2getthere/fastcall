{"version":3,"sources":["lib/TooTallNates/struct.js"],"names":["ref","require","util","assert","debug","module","exports","Struct","StructType","arg","data","store","Buffer","isBuffer","length","size","type","key","_instanceCreated","prototype","Object","create","proto","constructor","value","enumerable","writable","configurable","defineProperty","toString","fields","opt","arguments","alignment","indirection","isPacked","packed","Boolean","get","set","Array","isArray","forEach","a","name","keys","buffer","offset","slice","isStruct","copy","coerceType","equal","test","field","desc","recalc","struct","fieldNames","alignof","pointer","Math","min","max","fixedLength","addType","i","align","padding","sizeof","left","NULL","toObject","obj","k","toJSON","inspect"],"mappings":"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","file":"struct.js","sourcesContent":["\n/**\n * An interface for modeling and instantiating C-style data structures. This is\n * not a constructor per-say, but a constructor generator. It takes an array of\n * tuples, the left side being the type, and the right side being a field name.\n * The order should be the same order it would appear in the C-style struct\n * definition. It returns a function that can be used to construct an object that\n * reads and writes to the data structure using properties specified by the\n * initial field list.\n *\n * The only verboten field names are \"ref\", which is used used on struct\n * instances as a function to retrieve the backing Buffer instance of the\n * struct, and \"ref.buffer\" which contains the backing Buffer instance.\n *\n *\n * Example:\n *\n * ``` javascript\n * var ref = require('ref')\n * var Struct = require('ref-struct')\n *\n * // create the `char *` type\n * var charPtr = ref.refType(ref.types.char)\n * var int = ref.types.int\n *\n * // create the struct \"type\" / constructor\n * var PasswordEntry = Struct({\n *     'username': 'string'\n *   , 'password': 'string'\n *   , 'salt':     int\n * })\n *\n * // create an instance of the struct, backed a Buffer instance\n * var pwd = new PasswordEntry()\n * pwd.username = 'ricky'\n * pwd.password = 'rbransonlovesnode.js'\n * pwd.salt = (Math.random() * 1000000) | 0\n *\n * pwd.username // → 'ricky'\n * pwd.password // → 'rbransonlovesnode.js'\n * pwd.salt     // → 820088\n * ```\n */\n\n/**\n * Module dependencies.\n */\n\nvar ref = require('./ref')\nvar util = require('util')\nvar assert = require('assert')\nvar debug = require('debug')('ref:struct')\n\n/**\n * Module exports.\n */\n\nmodule.exports = Struct\n\n/**\n * The Struct \"type\" meta-constructor.\n */\n\nfunction Struct () {\n  debug('defining new struct \"type\"')\n\n  /**\n   * This is the \"constructor\" of the Struct type that gets returned.\n   *\n   * Invoke it with `new` to create a new Buffer instance backing the struct.\n   * Pass it an existing Buffer instance to use that as the backing buffer.\n   * Pass in an Object containing the struct fields to auto-populate the\n   * struct with the data.\n   */\n\n  function StructType (arg, data) {\n    if (!(this instanceof StructType)) {\n      return new StructType(arg, data)\n    }\n    debug('creating new struct instance')\n    var store\n    if (Buffer.isBuffer(arg)) {\n      debug('using passed-in Buffer instance to back the struct', arg)\n      assert(arg.length >= StructType.size, 'Buffer instance must be at least ' +\n          StructType.size + ' bytes to back this struct type')\n      store = arg\n      arg = data\n    } else {\n      debug('creating new Buffer instance to back the struct (size: %d)', StructType.size)\n      store = new Buffer(StructType.size)\n    }\n\n    // set the backing Buffer store\n    store.type = StructType\n    this['ref.buffer'] = store\n\n    if (arg) {\n      for (var key in arg) {\n        // hopefully hit the struct setters\n        this[key] = arg[key]\n      }\n    }\n    StructType._instanceCreated = true\n  }\n\n  // make instances inherit from the `proto`\n  StructType.prototype = Object.create(proto, {\n    constructor: {\n        value: StructType\n      , enumerable: false\n      , writable: true\n      , configurable: true\n    }\n  })\n\n  StructType.defineProperty = defineProperty\n  StructType.toString = toString\n  StructType.fields = {}\n\n  var opt = (arguments.length > 0 && arguments[1]) ? arguments[1] : {};\n  // Setup the ref \"type\" interface. The constructor doubles as the \"type\" object\n  StructType.size = 0\n  StructType.alignment = 0\n  StructType.indirection = 1\n  StructType.isPacked = opt.packed ? Boolean(opt.packed) : false\n  StructType.get = get\n  StructType.set = set\n\n  // Read the fields list and apply all the fields to the struct\n  // TODO: Better arg handling... (maybe look at ES6 binary data API?)\n  var arg = arguments[0]\n  if (Array.isArray(arg)) {\n    // legacy API\n    arg.forEach(function (a) {\n      var type = a[0]\n      var name = a[1]\n      StructType.defineProperty(name, type)\n    })\n  } else if (typeof arg === 'object') {\n    Object.keys(arg).forEach(function (name) {\n      var type = arg[name]\n      StructType.defineProperty(name, type)\n    })\n  }\n\n  return StructType\n}\n\n/**\n * The \"get\" function of the Struct \"type\" interface\n */\n\nfunction get (buffer, offset) {\n  debug('Struct \"type\" getter for buffer at offset', buffer, offset)\n  if (offset > 0) {\n    buffer = buffer.slice(offset)\n  }\n  return new this(buffer)\n}\n\n/**\n * The \"set\" function of the Struct \"type\" interface\n */\n\nfunction set (buffer, offset, value) {\n  debug('Struct \"type\" setter for buffer at offset', buffer, offset, value)\n  var isStruct = value instanceof this\n  if (isStruct) {\n    // optimization: copy the buffer contents directly rather\n    // than going through the ref-struct constructor\n    value['ref.buffer'].copy(buffer, offset, 0, this.size)\n  } else {\n    if (offset > 0) {\n      buffer = buffer.slice(offset)\n    }\n    new this(buffer, value)\n  }\n}\n\n/**\n * Custom `toString()` override for struct type instances.\n */\n\nfunction toString () {\n  return '[StructType]'\n}\n\n/**\n * Adds a new field to the struct instance with the given name and type.\n * Note that this function will throw an Error if any instances of the struct\n * type have already been created, therefore this function must be called at the\n * beginning, before any instances are created.\n */\n\nfunction defineProperty (name, type) {\n  debug('defining new struct type field', name)\n\n  // allow string types for convenience\n  type = ref.coerceType(type)\n\n  assert(!this._instanceCreated, 'an instance of this Struct type has already ' +\n      'been created, cannot add new \"fields\" anymore')\n  assert.equal('string', typeof name, 'expected a \"string\" field name')\n  assert(type && /object|function/i.test(typeof type) && 'size' in type &&\n      'indirection' in type\n      , 'expected a \"type\" object describing the field type: \"' + type + '\"')\n  assert(type.indirection > 1 || type.size > 0,\n      '\"type\" object must have a size greater than 0')\n  assert(!(name in this.prototype), 'the field \"' + name +\n      '\" already exists in this Struct type')\n\n  var field = {\n    type: type\n  }\n  this.fields[name] = field\n\n  // define the getter/setter property\n  var desc = { enumerable: true , configurable: true }\n  desc.get = function () {\n    debug('getting \"%s\" struct field (offset: %d)', name, field.offset)\n    return ref.get(this['ref.buffer'], field.offset, type)\n  }\n  desc.set = function (value) {\n    debug('setting \"%s\" struct field (offset: %d)', name, field.offset, value)\n    return ref.set(this['ref.buffer'], field.offset, value, type)\n  }\n\n  // calculate the new size and field offsets\n  recalc(this)\n\n  Object.defineProperty(this.prototype, name, desc)\n}\n\nfunction recalc (struct) {\n\n  // reset size and alignment\n  struct.size = 0\n  struct.alignment = 0\n\n  var fieldNames = Object.keys(struct.fields)\n\n  // first loop through is to determine the `alignment` of this struct\n  fieldNames.forEach(function (name) {\n    var field = struct.fields[name]\n    var type = field.type\n    var alignment = type.alignment || ref.alignof.pointer\n    if (type.indirection > 1) {\n      alignment = ref.alignof.pointer\n    }\n    if (struct.isPacked) {\n      struct.alignment = Math.min(struct.alignment || alignment, alignment)\n    } else {\n      struct.alignment = Math.max(struct.alignment, alignment)\n    }\n  })\n\n  // second loop through sets the `offset` property on each \"field\"\n  // object, and sets the `struct.size` as we go along\n  fieldNames.forEach(function (name) {\n    var field = struct.fields[name]\n    var type = field.type\n\n    if (null != type.fixedLength) {\n      // \"ref-array\" types set the \"fixedLength\" prop. don't treat arrays like one\n      // contiguous entity. instead, treat them like individual elements in the\n      // struct. doing this makes the padding end up being calculated correctly.\n      field.offset = addType(type.type)\n      for (var i = 1; i < type.fixedLength; i++) {\n        addType(type.type)\n      }\n    } else {\n      field.offset = addType(type)\n    }\n  })\n\n  function addType (type) {\n    var offset = struct.size\n    var align = type.indirection === 1 ? type.alignment : ref.alignof.pointer\n    var padding = struct.isPacked ? 0 : (align - (offset % align)) % align\n    var size = type.indirection === 1 ? type.size : ref.sizeof.pointer\n\n    offset += padding\n\n    if (!struct.isPacked) {\n      assert.equal(offset % align, 0, \"offset should align\")\n    }\n\n    // adjust the \"size\" of the struct type\n    struct.size = offset + size\n\n    // return the calulated offset\n    return offset\n  }\n\n  // any final padding?\n  var left = struct.size % struct.alignment\n  if (left > 0) {\n    debug('additional padding to the end of struct:', struct.alignment - left)\n    struct.size += struct.alignment - left\n  }\n}\n\n/**\n * this is the custom prototype of Struct type instances.\n */\n\nvar proto = {}\n\n/**\n * set a placeholder variable on the prototype so that defineProperty() will\n * throw an error if you try to define a struct field with the name \"buffer\".\n */\n\nproto['ref.buffer'] = ref.NULL\n\n/**\n * Flattens the Struct instance into a regular JavaScript Object. This function\n * \"gets\" all the defined properties.\n *\n * @api public\n */\n\nproto.toObject = function toObject () {\n  var obj = {}\n  Object.keys(this.constructor.fields).forEach(function (k) {\n    obj[k] = this[k]\n  }, this)\n  return obj\n}\n\n/**\n * Basic `JSON.stringify(struct)` support.\n */\n\nproto.toJSON = function toJSON () {\n  return this.toObject()\n}\n\n/**\n * `.inspect()` override. For the REPL.\n *\n * @api public\n */\n\nproto.inspect = function inspect () {\n  var obj = this.toObject()\n  // add instance's \"own properties\"\n  Object.keys(this).forEach(function (k) {\n    obj[k] = this[k]\n  }, this)\n  return util.inspect(obj)\n}\n\n/**\n * returns a Buffer pointing to this struct data structure.\n */\n\nproto.ref = function ref () {\n  return this['ref.buffer']\n}\n"]}