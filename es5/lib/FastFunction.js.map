{"version":3,"sources":["../../lib/FastFunction.js"],"names":["_","require","assert","Promise","native","dyncall","dynload","defs","callMode","FunctionDefinition","util","verify","ref","FastFunction","library","def","ptr","isObject","sync","async","_ptr","_vm","_function","_other","_type","function","findSymbol","_pLib","name","path","newCallVM","options","vmSize","_makeFunction","free","getFunction","initialize","_makeAsyncFunction","_makeSyncFunction","vmArgSetters","args","map","_findVMSetterFunc","arg","type","funcArgs","range","length","n","funcBody","i","synchronized","queued","Ctx","fn","vm","setVM","setVMAndReset","setter","indirection","specPtrDef","callback","struct","union","array","func","makePtr","cb","callerFunc","_makeCallerFunc","innerFunc","innerFuncArgs","concat","Function","err","Error","ctx","apply","arguments","_initFunction","hasPtrArg","Boolean","filter","head","finallyCode","f","ptrs","push","promisify","self","Object","defineProperties","get","findFastcallFunc","isPtr","resultType","toFastcallName","isFunction","resultDerefType","derefType","result","module","exports"],"mappings":"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","file":"FastFunction.js","sourcesContent":["'use strict';\nconst _ = require('lodash');\nconst assert = require('assert');\nconst Promise = require('bluebird');\nconst native = require('./native');\nconst dyncall = native.dyncall;\nconst dynload = native.dynload;\nconst defs = require('./defs');\nconst callMode = defs.callMode;\nconst FunctionDefinition = require('./FunctionDefinition');\nconst util = require('util');\nconst verify = require('./verify');\nconst ref = require('./ref-libs/ref');\n\nclass FastFunction extends FunctionDefinition {\n    constructor(library, def, callMode, ptr) {\n        assert(_.isObject(library), '\"library\" is not an object.');\n        assert(callMode === defs.callMode.sync || callMode === defs.callMode.async, '\"callMode\" is invalid: ' + callMode);\n        super(library, def);\n        this.callMode = callMode;\n        this._ptr = ptr;\n        this._vm = null;\n        this._function = null;\n        this._other = null;\n        this._type.function = this;\n    }\n\n    initialize() {\n        if (!this._ptr) {\n            this._ptr = dynload.findSymbol(this.library._pLib, this.name);\n        }\n        assert(this._ptr, `Symbol \"${ this.name }\" not found in library \"${ this.library.path }\".`);\n        this._vm = dyncall.newCallVM(this.library.options.vmSize);\n        this._function = this._makeFunction();\n    }\n\n    release() {\n        dyncall.free(this._vm);\n    }\n\n    getFunction() {\n        assert(this._function, this.name + ' is not initialized.');\n        return this._function;\n    }\n\n    sync() {\n        if (this.callMode === defs.callMode.sync) {\n            return this.getFunction();\n        }\n        if (!this._other) {\n            this._other = new FastFunction(this.library, this, defs.callMode.sync, this._ptr);\n            this._other.initialize();\n        }\n        return this._other.getFunction();\n    }\n\n    async() {\n        if (this.callMode === defs.callMode.async) {\n            return this.getFunction();\n        }\n        if (!this._other) {\n            this._other = new FastFunction(this.library, this, defs.callMode.async, this._ptr);\n            this._other.initialize();\n        }\n        return this._other.getFunction();\n    }\n\n    _makeFunction() {\n        if (this.callMode === defs.callMode.async) {\n            return this._makeAsyncFunction();\n        }\n        return this._makeSyncFunction();\n    }\n\n    _makeSyncFunction() {\n        const vmArgSetters = this.args.map(arg => this._findVMSetterFunc(arg.type));\n        const funcArgs = _.range(vmArgSetters.length).map(n => 'arg' + n);\n        let funcBody = 'this.setVM(this.vm);';\n        for (let i = 0; i < vmArgSetters.length; i++) {\n            funcBody += `this.argSetter${ i }(arg${ i });`;\n        }\n        if (this.library.synchronized) {\n            funcBody += 'this.library._lock();';\n            funcBody += 'try {';\n            funcBody += 'return this.callerFunc();';\n            funcBody += '}';\n            funcBody += 'finally {';\n            funcBody += 'this.library._unlock();';\n            funcBody += '}';\n        }\n        else {\n            if (this.library.queued) {\n                funcBody += 'this.library._assertQueueEmpty();';\n            }\n            funcBody += 'return this.callerFunc();';\n        }\n\n        class Ctx {\n            constructor(fn) {\n                this.library = fn.library;\n                this.vm = fn._vm;\n                this.setVM = dyncall.setVMAndReset;\n                let i = 0;\n                for (const setter of vmArgSetters) {\n                    if (setter.type.indirection === 2) {\n                        const specPtrDef = setter.type.callback || \n                            setter.type.struct || \n                            setter.type.union ||\n                            setter.type.array;\n                        if (specPtrDef) {\n                            this['argSetter' + i++] =\n                                cb => setter.func(specPtrDef.makePtr(cb));\n                            continue;\n                        }\n                    }\n                    this['argSetter' + i++] = setter.func;\n                }\n                this.callerFunc = fn._makeCallerFunc();\n            }\n        }\n\n        let innerFunc;\n        try {\n            const innerFuncArgs = funcArgs.concat([funcBody]);\n            innerFunc = new Function(...innerFuncArgs);\n        }\n        catch (err) {\n            throw Error('Invalid function body: ' + funcBody);\n        }\n        const ctx = new Ctx(this);\n        const func = function () {\n            return innerFunc.apply(ctx, arguments);\n        };\n        return this._initFunction(func);\n    }\n\n    _makeAsyncFunction() {\n        const vmArgSetters = this.args.map(arg => this._findVMSetterFunc(arg.type));\n        const hasPtrArg = Boolean(_(vmArgSetters).filter(setter => setter.type.indirection > 1).head());\n        const funcArgs = _.range(vmArgSetters.length).map(n => 'arg' + n);\n        let funcBody = hasPtrArg ? 'let ptrs = [];' : '';\n        funcBody += 'const myVM = this.vm;';\n        funcBody += 'this.setVM(myVM);';\n        for (let i = 0; i < vmArgSetters.length; i++) {\n            const setter = vmArgSetters[i];\n            if (setter.type.indirection > 1) {\n                funcBody += `this.argSetter${ i }(arg${ i }, ptrs);`;\n            }\n            else {\n                funcBody += `this.argSetter${ i }(arg${ i });`;\n            }\n        }\n\n        let finallyCode = '{';\n        if (this.library.synchronized) {\n            finallyCode += 'this.library._unlock();';\n            funcBody += 'this.library._lock();';\n        }\n        if (hasPtrArg) {\n            finallyCode += 'ptrs = null;';\n        }\n        finallyCode += '}';\n\n        const f = `return this.callerFunc(myVM).finally(() => ${ finallyCode });`;\n        if (this.library.queued) {\n            funcBody += `return this.library._enqueue(() => { ${ f } });`;\n        }\n        else {\n            funcBody += f;\n        }\n\n        class Ctx {\n            constructor(fn) {\n                this.library = fn.library;\n                this.setVM = dyncall.setVM;\n                this.free = dyncall.free;\n                let i = 0;\n                for (const setter of vmArgSetters) {\n                    if (setter.type.indirection > 1) {\n                        this['argSetter' + i++] = (ptr, ptrs) => {\n                            let _ptr;\n                            const specPtrDef = setter.type.callback || \n                                setter.type.struct || \n                                setter.type.union ||\n                                setter.type.array;\n                            if (setter.type.indirection === 2 && specPtrDef) {\n                                _ptr = specPtrDef.makePtr(ptr);\n                            }\n                            else {\n                                _ptr = ptr;\n                            }\n                            ptrs.push(_ptr);\n                            setter.func(_ptr);\n                        };\n                    }\n                    else {\n                        this['argSetter' + i++] = setter.func;\n                    }\n                }\n                this.callerFunc = Promise.promisify(fn._makeCallerFunc());\n                this.vm = null;\n            }\n        }\n\n        const ctx = new Ctx(this);\n        const vmSize = this.library.options.vmSize;\n\n        let innerFunc;\n        try {\n            innerFunc = new Function(...funcArgs.concat([funcBody]));\n        }\n        catch (err) {\n            throw Error('Invalid function body: ' + funcBody);\n        }\n\n        const func = function () {\n            ctx.vm = dyncall.newCallVM(vmSize);\n            return innerFunc.apply(ctx, arguments);\n        };\n        return this._initFunction(func);\n    }\n\n    _initFunction(func) {\n        func.function = this;\n        func.type = this.type;\n        const self = this;\n        Object.defineProperties(func, {\n            sync: {\n                get: function () {\n                    return self.sync();\n                }\n            },\n            async: {\n                get: function () {\n                    return self.async();\n                }\n            }\n        });\n        return func;\n    }\n\n    _findVMSetterFunc(type) {\n        return this.findFastcallFunc(dyncall, 'arg', type);\n    }\n\n    _makeCallerFunc() {\n        let name;\n        let isPtr = false;\n        let async = false;\n        if (this.resultType.indirection > 1) {\n            name = 'callPointer';\n            isPtr = true;\n        }\n        else {\n            name = 'call' + this.toFastcallName(this.resultType.name);\n        }\n        if (this.callMode === defs.callMode.async) {\n            name += 'Async';\n            async = true;\n        }\n\n        const func = dyncall[name];\n        verify(_.isFunction(func));\n\n        if (async) {\n            if (isPtr) {\n                const resultDerefType = ref.derefType(this.resultType);\n                return (vm, callback) => {\n                    func(vm, this._ptr, (err, result) => {\n                        if (err) {\n                            return callback(err);\n                        }\n                        result.type = resultDerefType;\n                        callback(null, result);\n                    });\n                }\n            }\n\n            return (vm, callback) => func(vm, this._ptr, callback);\n        }\n\n        if (isPtr) {\n            const resultDerefType = ref.derefType(this.resultType);\n            return () => {\n                const result = func(this._ptr);\n                result.type = resultDerefType;\n                return result;\n            }\n        }\n\n        return () => func(this._ptr);\n    }\n}\n\nmodule.exports = FastFunction;"]}